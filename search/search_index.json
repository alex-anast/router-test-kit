{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Router Test Kit","text":"<p>The motivation for this project is to provide a simple and out-of-the-box, easy-to-use framework for testing (virtual) routers. Initially, the framework was designed to work with OneOS6 routers from OneAccess Networks. It is based on a telnet connection, therefore it is compatible with CISCO routers, Ubuntu Server images etc.</p> <p>For Demo purposes, we use two Ubuntu Server Virtual Machines. See the DEMO section on the front page.</p>"},{"location":"installation/","title":"Installation Steps","text":"<p>The project is available on PyPi, so you can install it using <code>pip</code>:</p> <pre><code>python3 -m pip install router-test-kit\n</code></pre> <p>Alternatively, you can clone the repository and install it locally:</p> <pre><code>git clone git@github.com:alex-anast/router-test-kit.git\n</code></pre>"},{"location":"release-process/","title":"Release Process","text":"<p>This document describes the automated release process for Router Test Kit.</p>"},{"location":"release-process/#overview","title":"Overview","text":"<p>Router Test Kit uses an automated release pipeline that: - \ud83c\udff7\ufe0f Triggers on version tags (e.g., <code>v0.2.0</code>) - \ud83d\udcdd Generates release notes from git history - \ud83d\udce6 Builds and publishes to PyPI - \ud83c\udf89 Creates GitHub releases - \ud83d\udccb Updates changelog automatically</p>"},{"location":"release-process/#quick-release","title":"Quick Release","text":"<p>To create a new release:</p> <ol> <li> <p>Update Version in <code>pyproject.toml</code>:    <pre><code>[project]\nversion = \"0.3.0\"  # Bump version\n</code></pre></p> </li> <li> <p>Commit Changes:    <pre><code>git add pyproject.toml\ngit commit -m \"feat: bump version to 0.3.0\"\ngit push origin main\n</code></pre></p> </li> <li> <p>Create and Push Tag:    <pre><code>git tag v0.3.0\ngit push origin v0.3.0\n</code></pre></p> </li> <li> <p>Automation Handles the Rest \ud83d\ude80</p> </li> <li>GitHub Actions will automatically:<ul> <li>Run all tests and checks</li> <li>Build the package</li> <li>Generate release notes</li> <li>Create GitHub release</li> <li>Publish to PyPI</li> </ul> </li> </ol>"},{"location":"release-process/#detailed-process","title":"Detailed Process","text":""},{"location":"release-process/#1-version-management","title":"1. Version Management","text":"<p>The project follows Semantic Versioning:</p> <ul> <li>MAJOR (1.0.0): Breaking changes</li> <li>MINOR (0.1.0): New features (backwards compatible)</li> <li>PATCH (0.0.1): Bug fixes (backwards compatible)</li> </ul> <p>Examples: - <code>0.1.0</code> \u2192 <code>0.2.0</code>: New plugin system (minor) - <code>0.2.0</code> \u2192 <code>0.2.1</code>: Bug fix (patch) - <code>0.2.1</code> \u2192 <code>1.0.0</code>: Breaking API change (major)</p>"},{"location":"release-process/#2-pre-release-checklist","title":"2. Pre-Release Checklist","text":"<p>Before creating a release:</p> <ul> <li>[ ] All tests pass locally: <code>python -m pytest</code></li> <li>[ ] Code coverage is adequate: <code>python -m pytest --cov</code></li> <li>[ ] Documentation is updated</li> <li>[ ] Version number is bumped in <code>pyproject.toml</code></li> <li>[ ] Notable changes are ready for changelog</li> </ul>"},{"location":"release-process/#3-automated-workflow","title":"3. Automated Workflow","text":"<p>When you push a version tag, the CI/CD pipeline:</p> <pre><code>graph LR\n    A[Push Tag v1.2.3] --&gt; B[Run Tests]\n    B --&gt; C[Security Scan]\n    C --&gt; D[Build Package]\n    D --&gt; E[Generate Notes]\n    E --&gt; F[Create Release]\n    F --&gt; G[Publish PyPI]</code></pre>"},{"location":"release-process/#workflow-steps","title":"Workflow Steps:","text":"<ol> <li>Validation:</li> <li>Verify tag format (<code>v1.2.3</code>)</li> <li>Check version matches <code>pyproject.toml</code></li> <li>Run full test suite</li> <li> <p>Perform security scanning</p> </li> <li> <p>Build:</p> </li> <li>Create source distribution (<code>.tar.gz</code>)</li> <li>Create wheel distribution (<code>.whl</code>)</li> <li> <p>Verify package contents</p> </li> <li> <p>Release Notes:</p> </li> <li>Parse git history since last tag</li> <li>Categorize commits by type</li> <li> <p>Generate formatted release notes</p> </li> <li> <p>Publish:</p> </li> <li>Create GitHub release with notes</li> <li>Upload package artifacts</li> <li>Publish to PyPI with trusted publishing</li> </ol>"},{"location":"release-process/#4-manual-release-emergency","title":"4. Manual Release (Emergency)","text":"<p>If automation fails, you can release manually:</p> <pre><code># Build package\npython -m pip install build\npython -m build\n\n# Check package\npython -m pip install twine\npython -m twine check dist/*\n\n# Upload to PyPI (requires API token)\npython -m twine upload dist/*\n</code></pre>"},{"location":"release-process/#configuration","title":"Configuration","text":""},{"location":"release-process/#github-secrets","title":"GitHub Secrets","text":"<p>Required secrets for automated releases:</p> <ul> <li><code>PYPI_API_TOKEN</code>: PyPI trusted publishing token</li> <li><code>GITHUB_TOKEN</code>: Automatically provided by GitHub</li> </ul>"},{"location":"release-process/#pypi-configuration","title":"PyPI Configuration","text":"<p>The project uses PyPI Trusted Publishing for secure, token-less publishing.</p> <p>Setup: 1. Go to PyPI project settings 2. Add GitHub as trusted publisher 3. Configure repository details</p>"},{"location":"release-process/#release-notes","title":"Release Notes","text":"<p>Release notes are automatically generated from git commits using these patterns:</p> Commit Pattern Category Example <code>feat:</code>, <code>add:</code> \u2728 New Features <code>feat: add plugin system</code> <code>fix:</code>, <code>bug:</code> \ud83d\udc1b Bug Fixes <code>fix: connection timeout</code> <code>docs:</code>, <code>doc:</code> \ud83d\udcda Documentation <code>docs: update API guide</code> <code>test:</code>, <code>tests:</code> \ud83e\uddea Testing <code>test: add unit tests</code> <code>ci:</code>, <code>cd:</code> \u2699\ufe0f CI/CD <code>ci: improve workflow</code> Others \ud83d\udd27 Other Changes <code>refactor: cleanup code</code> <p>Best Practices: - Use descriptive commit messages - Start with action verb - Keep first line under 50 characters - Reference issues when applicable</p>"},{"location":"release-process/#troubleshooting","title":"Troubleshooting","text":""},{"location":"release-process/#common-issues","title":"Common Issues","text":"<p>1. Version Mismatch Error <pre><code>Error: Version mismatch between tag (1.2.3) and pyproject.toml (1.2.2)\n</code></pre> Solution: Update version in <code>pyproject.toml</code> before tagging.</p> <p>2. PyPI Upload Fails <pre><code>ERROR: File already exists\n</code></pre> Solution: Versions cannot be re-uploaded. Bump version and re-tag.</p> <p>3. Tests Fail on Release <pre><code>FAILED tests/test_module.py::test_function\n</code></pre> Solution: Fix tests before tagging. All tests must pass.</p>"},{"location":"release-process/#rollback-process","title":"Rollback Process","text":"<p>If a release has issues:</p> <ol> <li>Mark Release as Draft (GitHub)</li> <li>Yank Package (PyPI if necessary):    <pre><code>pip install twine\ntwine upload --repository pypi --skip-existing dist/*\n</code></pre></li> <li>Fix Issues and create new release</li> </ol>"},{"location":"release-process/#monitoring","title":"Monitoring","text":"<p>After release, monitor:</p> <ul> <li>GitHub Release Page</li> <li>PyPI Package Page</li> <li>GitHub Actions</li> <li>Download statistics and user feedback</li> </ul>"},{"location":"release-process/#security","title":"Security","text":"<p>Release process security measures:</p> <ul> <li>\u2705 Automated security scanning with Bandit</li> <li>\u2705 Dependency vulnerability checking</li> <li>\u2705 Trusted publishing (no API tokens in workflows)</li> <li>\u2705 Signed releases with GitHub</li> <li>\u2705 Reproducible builds</li> </ul>"},{"location":"release-process/#quick-reference","title":"Quick Reference","text":"<pre><code># Check current version\ngrep version pyproject.toml\n\n# Create release\nvim pyproject.toml  # Update version\ngit add pyproject.toml\ngit commit -m \"feat: bump version to X.Y.Z\"\ngit tag vX.Y.Z\ngit push origin main vX.Y.Z\n\n# Monitor release\nopen https://github.com/alex-anast/router-test-kit/actions\n</code></pre> <p>For questions or issues with releases, open an issue or contact the maintainers.</p>"},{"location":"usage/","title":"How to Use","text":"<p>Assuming that the prerequisites are met and the installation has been successful, you can start using the test framework right away.</p>"},{"location":"usage/#examples","title":"Examples","text":"<p>For examples, see the <code>./examples/example1_connect.py</code> and <code>./examples/example2_ping_between_vms.py</code> files. For a very thorough example showcasing the full capabilities of the test framework, see <code>./tests/test_ipsec.py</code>.</p>"},{"location":"usage/#core-parts-of-any-test","title":"Core Parts of any Test","text":"<p>The two most important parts of writing a network setup test are:</p> <ul> <li> <p><code>device.py::Device</code> class: As in the real world, you have to let the test know that you are connection from a <code>HostDevice</code> to a destination device that can be any of the children classes: <code>LinuxDevice</code>, <code>RadiusServer</code>, <code>OneOS6Device</code>, etc.</p> </li> <li> <p><code>connection.py::Connection</code> class: The connection from the host device to the destination device. For the time being, only one connection is supported, the <code>TelnetConnection</code>. Alongside this, for the case where you need to connect to a device and from there, to jump to a third device, use the <code>TelnetCLIConnection</code> class. This includes several protection mechanisms for the connections to work well together as a group.</p> </li> </ul>"},{"location":"usage/#script-example","title":"Script Example","text":"<p>The steps that should be taken for establishing and killing a connection are given below:</p> <pre><code># Register device(s)\nvm = LinuxDevice(username=\"user\", password=\"password\")\n\n# Create a `connection` instance\nmy_connection = TelnetConnection(timeout=10)\n\n# Connect to the device using telnet\nconnection = connection.connect(\n    destination_device=vm,\n    destination_ip=\"192.168.10.10\",\n)\n\n# Perform actions, like ping, execute command on device etc.\n\n# Close the connection\nconnection.disconnect()\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>Welcome to the Router Test Kit API documentation. This section provides comprehensive documentation for all modules, classes, and functions in the router-test-kit framework.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>The Router Test Kit is organized into several core modules:</p> <ul> <li>Connection - Network connection management (SSH and Telnet)</li> <li>Device - Device abstraction and management</li> <li>Static Utils - Utility functions and helpers</li> </ul>"},{"location":"api/#architecture","title":"Architecture","text":"<p>The framework follows a clean separation of concerns:</p> <pre><code>graph TD\n    A[Test Script] --&gt; B[Device Objects]\n    A --&gt; C[Connection Objects]\n    A --&gt; D[Static Utils]\n    B --&gt; C\n    C --&gt; E[Network Device]\n    D --&gt; F[System Commands]</code></pre>"},{"location":"api/#design-principles","title":"Design Principles","text":"<ol> <li>Security First: Modern SSH connections are preferred over legacy Telnet</li> <li>Type Safety: Comprehensive type hints for better IDE support and error prevention</li> <li>Error Handling: Robust error handling with informative exception messages</li> <li>Testability: Extensive unit test coverage with mocking support</li> <li>Documentation: Comprehensive docstrings following Google style</li> </ol>"},{"location":"api/#quick-start","title":"Quick Start","text":"<p>Here's a basic example of using the API:</p> <pre><code>from router_test_kit.connection import SSHConnection\nfrom router_test_kit.device import LinuxDevice\nfrom router_test_kit.static_utils import ping, get_packet_loss\n\n# Create device and connection\ndevice = LinuxDevice(username=\"admin\", password=\"password\")\nconn = SSHConnection(timeout=30)\n\n# Connect and execute commands\nconn.connect(device, \"192.168.1.1\")\nresult = conn.write_command(\"show version\")\nconn.disconnect()\n\n# Network utilities\nping_result = ping(\"8.8.8.8\", count=3)\npacket_loss = get_packet_loss(ping_result)\n</code></pre>"},{"location":"api/#security-notice","title":"Security Notice","text":"<p>Telnet Deprecation</p> <p>The TelnetConnection class is deprecated due to security concerns. Telnet transmits data in plain text, making it vulnerable to eavesdropping and man-in-the-middle attacks. </p> <p>All new implementations should use SSHConnection for secure communications.</p> <p>Telnet support will be removed in a future major version.</p>"},{"location":"api/#migration-guide","title":"Migration Guide","text":"<p>If you're currently using TelnetConnection, migrating to SSHConnection is straightforward:</p> <pre><code># Old (deprecated)\nfrom router_test_kit.connection import TelnetConnection\nconn = TelnetConnection()\n\n# New (recommended)  \nfrom router_test_kit.connection import SSHConnection\nconn = SSHConnection()\n\n# The API is identical for connect(), disconnect(), and write_command()\n</code></pre>"},{"location":"api/#support","title":"Support","text":"<p>For questions, issues, or contributions, please visit the GitHub repository.</p>"},{"location":"api/connection/","title":"Connection API","text":"<p>The connection module provides network connection management capabilities for communicating with remote devices.</p> <p>Network Connection Management Module.</p> <p>This module provides a comprehensive framework for establishing and managing network connections to remote devices, with support for both secure SSH and legacy Telnet protocols.</p> <p>The module implements a connection hierarchy with an abstract base class and concrete implementations for different connection types:</p> <ul> <li>Connection (ABC): Abstract base class defining the connection interface</li> <li>SSHConnection: Secure SSH connections using paramiko (recommended)</li> <li>TelnetConnection: Legacy telnet connections (deprecated)</li> </ul> <p>Classes:</p> Name Description <code>Connection</code> <p>Abstract base class for all connection types</p> <code>SSHConnection</code> <p>Secure SSH connection implementation</p> <code>TelnetConnection</code> <p>Legacy telnet connection (deprecated)</p> Example <p>Basic SSH connection usage:</p> <pre><code>from router_test_kit.connection import SSHConnection\nfrom router_test_kit.device import LinuxDevice\n\n# Create device and connection\ndevice = LinuxDevice(username=\"admin\", password=\"password\")\nconn = SSHConnection(timeout=30)\n\n# Connect and execute commands\nconn.connect(device, \"192.168.1.1\")\nresult = conn.write_command(\"show version\")\nconn.disconnect()\n</code></pre> Security Notice <p>This module includes deprecated telnet functionality for backward compatibility. All new implementations should use SSHConnection for secure communications. Telnet support will be removed in a future major version.</p>"},{"location":"api/connection/#router_test_kit.connection-classes","title":"Classes","text":""},{"location":"api/connection/#router_test_kit.connection.Connection","title":"Connection","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for network connections to remote devices.</p> <p>This class defines the interface that all connection implementations must follow. It provides common functionality for connection management including timeout handling, device association, and connection state tracking.</p> <p>The class includes decorators for ensuring connection exclusivity and device type validation, which are used by concrete implementations.</p> <p>Attributes:</p> Name Type Description <code>destination_device</code> <code>Optional[Device]</code> <p>The target device for this connection</p> <code>destination_ip</code> <code>Optional[str]</code> <p>IP address of the destination device</p> <code>timeout</code> <code>int</code> <p>Connection timeout in seconds (default: 10)</p> <code>prompt_symbol</code> <code>Optional[str]</code> <p>Expected command prompt symbol</p> Private Attributes <p>_is_occupied (bool): Indicates if connection is in use by another process</p> Example <p>This is an abstract class and cannot be instantiated directly. Use concrete implementations like SSHConnection:</p> <pre><code>conn = SSHConnection(timeout=30)\nconn.connect(device, \"192.168.1.1\")\n</code></pre> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>class Connection(ABC):\n    \"\"\"Abstract base class for network connections to remote devices.\n\n    This class defines the interface that all connection implementations must follow.\n    It provides common functionality for connection management including timeout handling,\n    device association, and connection state tracking.\n\n    The class includes decorators for ensuring connection exclusivity and device type\n    validation, which are used by concrete implementations.\n\n    Attributes:\n        destination_device (Optional[Device]): The target device for this connection\n        destination_ip (Optional[str]): IP address of the destination device\n        timeout (int): Connection timeout in seconds (default: 10)\n        prompt_symbol (Optional[str]): Expected command prompt symbol\n\n    Private Attributes:\n        _is_occupied (bool): Indicates if connection is in use by another process\n\n    Example:\n        This is an abstract class and cannot be instantiated directly.\n        Use concrete implementations like SSHConnection:\n\n        ```python\n        conn = SSHConnection(timeout=30)\n        conn.connect(device, \"192.168.1.1\")\n        ```\n    \"\"\"\n\n    def __init__(self, timeout: int = 10):\n        \"\"\"Initialize a new connection instance.\n\n        Args:\n            timeout: Connection timeout in seconds. Defaults to 10.\n\n        Note:\n            This is an abstract class and should not be instantiated directly.\n            Use concrete implementations like SSHConnection or TelnetConnection.\n        \"\"\"\n        self.destination_device = None\n        self.destination_ip = None\n        self.resulting_telnet_connection = None\n        self.timeout = timeout\n        self._is_occupied = (\n            False  # Signifies if the connection is in use by another connection\n        )\n        self.prompt_symbol = None\n\n    @abstractmethod\n    def connect(self, destination_device: \"Device\", destination_ip: str) -&gt; \"Connection\":\n        \"\"\"Establish a connection to the specified device.\n\n        This method must be implemented by concrete connection classes to establish\n        the actual network connection to the target device.\n\n        Args:\n            destination_device: The device object containing connection credentials\n            destination_ip: IP address of the target device\n\n        Returns:\n            Connection: This connection instance for method chaining\n\n        Raises:\n            ConnectionAbortedError: If the connection cannot be established\n            TimeoutError: If the connection attempt times out\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def disconnect(self) -&gt; None:\n        \"\"\"Close the connection to the remote device.\n\n        This method must be implemented by concrete connection classes to properly\n        close and clean up the network connection.\n\n        Note:\n            After calling this method, the connection object should not be used\n            for further communication until connect() is called again.\n        \"\"\"\n        pass\n\n    def check_occupied(func):\n        \"\"\"\n        Decorator to check if the connection is already in use and hence not available.\n\n        This decorator is used to wrap methods that should not be executed if the connection is already in use.\n\n        Raises:\n            ConnectionRefusedError: If the connection is already in use.\n        \"\"\"\n\n        def wrapper(self, *args, **kwargs):\n            if self._is_occupied:\n                raise ConnectionRefusedError(\n                    \"This connection is already in use. Please close the connections that use it first.\"\n                )\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    def check_device_type(required_type, is_root: bool = False):\n        \"\"\"\n        Decorator to check the device type and connection privileges before executing a function.\n\n        Args:\n            required_type (str): The required device type for the function to be executed.\n            is_root (bool, optional): If True, the function requires root privileges to be executed. Defaults to False.\n\n        Raises:\n            ValueError: If the device is not of the required type.\n            ConnectionError: If the device is not connected.\n            PermissionError: If root privileges are required but the user does not have them.\n        \"\"\"\n\n        def decorator(func):\n            def wrapper(self, *args, **kwargs):\n                if self.destination_device.type != required_type:\n                    raise ValueError(\n                        f'This method is available only for {required_type} devices, but the destination device is of type \"{self.destination_device.type}\".'\n                    )\n                # Perform the connection check too, since it's a common requirement\n                if not self.is_connected:\n                    raise ConnectionError(\"Device is not connected\")\n                if is_root and not self.is_root:\n                    raise PermissionError(\n                        \"Root privileges required to perform this action\"\n                    )\n                return func(self, *args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    def check_connection(func):\n        \"\"\"\n        Decorator to check if the device is connected before executing a function.\n\n        Raises:\n            ConnectionError: If the device is not connected.\n        \"\"\"\n\n        def wrapper(self, *args, **kwargs):\n            if not self.is_connected:\n                raise ConnectionError(\"Device is not connected\")\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    @check_occupied\n    def write_command(\n        self,\n        command: str,\n        expected_prompt_pattern: Optional[List[str]] = None,\n        timeout: Optional[int] = None,\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Writes a command to the telnet connection and returns the response.\n\n        This method sends a command to the device via the telnet connection, waits for a response, and then returns that response.\n        The response is expected to end with a prompt symbol or match an expected pattern, which is specified by the `expected_prompt_pattern` parameter.\n\n        Args:\n            command (str): The command to be sent to the device.\n            expected_prompt_pattern (Optional[List[str]]): A list of regex patterns that the response is expected to match. If None, the method waits for the prompt symbol. Defaults to None.\n            timeout (Optional[int]): The maximum time to wait for a response, in seconds. If None, the method uses the default timeout. Defaults to None.\n\n        Returns:\n            Optional[str]: The response from the device, or None if there was no response.\n\n        Raises:\n            ConnectionError: If the telnet connection is not established.\n        \"\"\"\n        self.flush()  # Make sure nothing is in the buffer\n\n        if self.resulting_telnet_connection is not None:\n            # If the command is a string, encode it to bytes first\n            command = (\n                command.encode(\"ascii\") + b\"\\r\"\n                if hasattr(command, \"encode\")\n                else command\n            )\n            self.resulting_telnet_connection.write(command)\n            assert self.prompt_symbol is not None, \"Prompt symbol is not defined.\"\n\n            # \"expect\" can wait for multiple patterns\n            if expected_prompt_pattern:\n                response = self.resulting_telnet_connection.expect(\n                    expected_prompt_pattern,\n                    timeout or self.timeout,\n                )[2]  # The third element of the tuple is the response\n            # but \"read_until\", while only for one pattern (prompt_symbol), is more reliable\n            else:\n                response = self.resulting_telnet_connection.read_until(\n                    self.prompt_symbol.encode(\"ascii\"), timeout or self.timeout\n                )\n            response = response.decode(\"ascii\") if response else None\n        else:\n            raise ConnectionError(\n                \"No connection object from Telnet found during write_command.\"\n            )\n        return response\n\n    @check_occupied\n    def flush(self, time_interval: int = 0.1) -&gt; None:\n        \"\"\"\n        This method waits for a short period of time to allow any remaining data to arrive,\n        then reads and discards all data that has arrived at the telnet connection.\n        \"\"\"\n        try:\n            time.sleep(time_interval)\n            if self.resulting_telnet_connection is not None:\n                self.resulting_telnet_connection.read_very_eager()\n        except EOFError as eof:\n            logger.error(\n                f\"EOFError. Usually something is wrong while loading the connection. | {eof}\"\n            )\n            raise EOFError from eof\n\n    @check_occupied\n    def flush_deep(self, time_interval: int = 0.1, retries_timeout: int = 60) -&gt; None:\n        logger.debug(\"Deep flushing ...\")\n        end_pattern = f\"{self.prompt_symbol}\"\n        if retries_timeout &gt; 0:\n            start_time = time.time()\n        while True:\n            response = self.write_command(\"\\n\", timeout=time_interval)\n            if response is not None and end_pattern in response.strip():\n                break\n            if retries_timeout &gt; 0 and time.time() - start_time &gt; retries_timeout:\n                raise TimeoutError(\"Timeout while flushing deep\")\n\n    @property\n    @abstractmethod\n    def is_connected(self) -&gt; bool:\n        pass\n\n    @check_occupied\n    def read_until(self, prompt: bytes, timeout: Optional[int] = None) -&gt; Optional[str]:\n        \"\"\"\n        Reads data from the telnet connection until a specified prompt is encountered or until timeout.\n\n        Args:\n            prompt (bytes): The prompt to read until.\n            timeout (Optional[int]): The maximum time to wait for the prompt, in seconds. If None, the method uses the default timeout. Defaults to None.\n\n        Returns:\n            Optional[str]: The data read from the connection, or None if no data was read.\n        \"\"\"\n        if timeout is not None:\n            self.timeout = timeout\n        if self.resulting_telnet_connection is not None:\n            response = self.resulting_telnet_connection.read_until(prompt, self.timeout)\n            response = response.decode(\"ascii\") if response else None\n        else:\n            raise NotImplementedError(\n                \"No connection object from Telnet found during read_until.\"\n            )\n        return response\n\n    @check_device_type(\"oneos\")\n    def load_config(self, config_path: str) -&gt; None:\n        \"\"\"\n        Loads a configuration file to a OneOS device.\n\n        Args:\n            config_path (str): The path to the configuration file.\n\n        Raises:\n            ValueError: If the device is not a OneOS device.\n            OSError: If the configuration file fails to open (might not exist).\n            ConnectionError: If the device is not connected.\n        \"\"\"\n        logger.debug(f\"Loading config {config_path.split('/')[-1]} ...\")\n        self.write_command(\"term len 0\")\n        with open(config_path) as fp:\n            for line in fp:\n                if line.strip().startswith(\"!\"):\n                    continue  # Skip comment lines\n                if \"hostname\" in line:\n                    self.destination_device.hostname = line.split()[-1]\n                response = self.write_command(line)\n\n        # Check that prompt has exited config terminal fully. Search for \"localhost#\" (default) or \"&lt;configured_hostname&gt;#\"\n        self.prompt_symbol = f\"{self.destination_device.hostname}#\"\n        response = self.write_command(\"\\n\").strip()\n        if response != self.prompt_symbol:\n            logger.warning(\n                f\"Loading config might have failed, prompt is not as expected. Received {response} but expected {self.prompt_symbol} instead\"\n            )\n            logger.debug(\n                'Sometimes the developer has miscalculated the \"exit\" commands in the BSA'\n            )\n            self.write_command(\"end\")\n        logger.info(\n            f\"Loaded configuration to device {self.destination_device.hostname}\"\n        )\n\n    @check_device_type(\"oneos\")\n    def patch_config(self, config_path: str) -&gt; None:\n        logger.debug(f\"Patching config {config_path.split('/')[-1]} ...\")\n        # If it has beed set as &lt;hostname&gt;&lt;prompt_symbol&gt;, just keep the &lt;prompt_symbol&gt;\n        # That is to avoid looking for \"localhost#\" but getting \"localhost(config)#\" during reconfig\n        if len(self.prompt_symbol) != 1:\n            self.prompt_symbol = self.prompt_symbol[-1]\n        self.load_config(config_path)\n\n    @check_device_type(\"linux\")\n    def set_sudo(self, root_password: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Sets sudo privileges for a Linux device.\n        The prompt symbol is updated to '#' to reflect the change to the root user.\n\n        Args:\n            root_password (Optional[str]): The root password. If None, the method uses the password of the destination device. Defaults to None.\n\n        Raises:\n            ValueError: If the device is not a Linux device.\n            ConnectionError: If the device is not connected.\n            AssertionError: If the method fails to switch to the root user.\n        \"\"\"\n        if root_password is None:\n            root_password = self.destination_device.password\n        self.write_command(\"sudo su\", expected_prompt_pattern=[b\"password for user:\"])\n        self.write_command(root_password, expected_prompt_pattern=[b\"#\"])\n        self.prompt_symbol = \"#\"  # In Linux, changes from '$' to '#' if root\n        assert self.is_root, \"Failed to identify root user\"\n        logger.info(\n            f\"Sudo privileges set for linux device: {self.destination_device.hostname}\"\n        )\n\n    @property\n    def is_root(self) -&gt; bool:\n        \"\"\"\n        Checks if the current user is root on a Linux device by writing the 'whoami' command and checking the response.\n\n        Returns:\n            bool: True if the current user is root, False otherwise.\n        \"\"\"\n        user = self.write_command(\"whoami\", [rb\"\\$\", b\"#\"]).split()[1].strip()\n        return user == \"root\"\n\n    @check_device_type(\"linux\", is_root=True)\n    def set_interface_ip(\n        self,\n        interface_name: str,\n        ip_addr: str,\n        netmask: str = \"24\",\n        interface_state: str = \"up\",\n    ) -&gt; None:\n        \"\"\"\n        Sets the IP address, netmask, and state of a specified interface on a Linux device.\n\n        Args:\n            interface_name (str): The name of the interface.\n            ip_addr (str): The IP address to set.\n            netmask (str, optional): The netmask to set. Defaults to \"24\".\n            interface_state (str, optional): The state of the interface. Must be 'up' or 'down'. Defaults to \"up\".\n\n        Raises:\n            ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n            ConnectionError: If the device is not connected.\n            PermissionError: If the user does not have root privileges.\n        \"\"\"\n        if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n            raise ValueError(\"Invalid IP address.\")\n        if interface_state not in [\"up\", \"down\"]:\n            logger.error(\n                f\"Invalid state: {interface_state}. Must be 'up' or 'down'. Passing 'up' by default.\"\n            )\n            interface_state = \"up\"\n        if self._get_interface(interface_name) is None:\n            raise ValueError(f\"Interface {interface_name} not found\")\n        self.write_command(f\"ip addr add {ip_addr}/{netmask} dev {interface_name}\")\n        self.write_command(f\"ip link set {interface_name} {interface_state}\")\n        logger.info(\n            f\"Interface {interface_name} set to IP {ip_addr} with netmask {netmask} and state {interface_state}\"\n        )\n\n    @check_device_type(\"linux\", is_root=True)\n    def delete_interface_ip(\n        self, interface_name: str, ip_addr: str, netmask: str = \"24\"\n    ) -&gt; None:\n        \"\"\"\n        Deletes the IP address from a specified interface on a Linux device.\n\n        Args:\n            interface_name (str): The name of the interface.\n            ip_addr (str): The IP address to delete.\n            netmask (str, optional): The netmask of the IP address. Defaults to \"24\".\n\n        Raises:\n            ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n            ConnectionError: If the device is not connected.\n            PermissionError: If the user does not have root privileges.\n        \"\"\"\n        if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n            raise ValueError(\"Invalid IP address.\")\n        if self._get_interface(interface_name) is None:\n            raise ValueError(f\"Interface {interface_name} not found\")\n        self.write_command(f\"ip addr del {ip_addr}/{netmask} dev {interface_name}\")\n        logger.info(\n            f\"IP {ip_addr} with netmask {netmask} deleted from interface {interface_name}\"\n        )\n\n    def _get_interfaces(self) -&gt; Optional[List[List[str]]]:\n        \"\"\"\n        Gets a list of all interfaces on the device.\n        \"\"\"\n        interfaces = re.split(r\"\\r\\n(?=\\d)\", self.write_command(\"ip a\"))[\n            1:\n        ]  # Disregard the CLI command\n        return interfaces\n\n    def _get_interface(self, interface_name: str):\n        \"\"\"\n        Gets information about a specific interface on the device.\n        \"\"\"\n        interface_list = self._get_interfaces()\n        for interface in interface_list:\n            if interface_name in interface:\n                return interface\n        return None\n\n    @check_device_type(\"oneos\")\n    def unload_interface(\n        self, interface_line: str, wrap_command: bool = True\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Resets the configuration of a specified interface to its default settings.\n        OneOS6 WARNING: \"By configuring the interface back to default, it is possible that some services will not work any more\"\n\n        Args:\n            interface_line (str): The line of the full interface name to reset (i.e. interface gigabitethernet 0/0).\n            wrap_command (bool, optional): If True, the method enters and exits the \"configure terminal\" command.\n\n        Returns:\n            Optional[str]: The response from the device after sending the 'default' command, or None if there was no response.\n        \"\"\"\n        self.write_command(\"config terminal\") if wrap_command else None\n        response = self.write_command(f\"default {interface_line}\")\n        self.write_command(\"end\") if wrap_command else None\n        return response\n\n    @check_device_type(\"oneos\")\n    def unload_config(\n        self,\n        unload_specific_commands: Optional[List[str]] = None,\n        check_is_empty: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Unloads the configuration of the device using a bottom-up approach.\n        The configurations on the bottom of the config inherit properties from the configurations above them.\n\n        Sometimes, even by that approach, some commands cannot be unloaded. In that case, the user must manually unload them,\n            by providing the no-commands in the unload_specific_commands parameter.\n\n        The config is retrieved by the very slow \"show running-config\" command. If check_is_empty is True,\n            \"show running-config\" is called again (another couple of seconds wait time), that's why default is to not check.\n\n        Args:\n            unload_specific_commands (Optional[List[str]]): A list of specific commands to unload. Defaults to None.\n            check_is_empty (bool, optional): If True, the method checks if the configuration is empty after unloading. Defaults to False.\n\n        Raises:\n            ValueError: If the configuration is not fully unloaded and check_is_empty is True, or if device type is not oneos.\n            ConnectionError: If the device is not connected.\n        \"\"\"\n        logger.debug(\n            f\"Unloading config for device {self.destination_device.hostname} ...\"\n        )\n        self.write_command(\"term len 0\")\n        self.flush()\n\n        config_lines = self.write_command(\"show running-config\").split(\"\\n\")\n        config_lines_reverse = config_lines[::-1]  # Traverse from bottom to top\n\n        self.prompt_symbol = \"#\"\n        self.write_command(\"config terminal\")\n\n        # Unload ip routes\n        for line in config_lines_reverse:\n            if re.search(r\"^(ip(v6|) (route|host)|aaa authentication login)\", line):\n                self.write_command(f\"no {line}\")\n            elif re.search(r\"^radius-server\", line):\n                self.write_command(f\"no radius-server {line.split(' ')[1]}\")\n            if \"exit\" in line:\n                break\n\n        # Unload interfaces\n        for line in config_lines_reverse:\n            if line.startswith(\"interface\"):\n                # If any of the interfaces listed in permanent_interfaces is a substring of the line\n                if any(\n                    interface in line\n                    for interface in self.destination_device.PHYSICAL_INTERFACES_LIST\n                ):\n                    self.unload_interface(line, wrap_command=False)\n                else:\n                    self.write_command(f\"no {line}\")\n\n        # Get all the lines until the first interface\n        interface_index = next(\n            (i for i, line in enumerate(config_lines) if line.startswith(\"interface\")),\n            None,\n        )\n        config_lines_until_interfaces = config_lines[:interface_index]\n        # Get all the lines that are not preceded with space -&gt; assumes that they are unloaded as part of the main line unload\n        main_lines = [\n            line\n            for line in config_lines_until_interfaces\n            if (not line.startswith(\" \") and \"exit\" not in line)\n        ]\n        for line in main_lines[:1:-1]:  # Traverse from bottom to top again\n            if \"license activate\" in line:\n                continue\n            # NOTE: Ignore cases that the \"no\" prefix will not work, expect the user to manually unload these in the loop below\n            self.write_command(f\"no {line}\")\n\n        # Finally, if user knows that there are configuration leftovers, unload it manually\n        if unload_specific_commands is not None:\n            for command in unload_specific_commands:\n                self.write_command(command)\n\n        self.write_command(\"hostname localhost\")\n        self.write_command(\"end\")\n        self.flush()\n\n        # NOTE: By default, keep check to False because \"show running-config\" takes ~4s to return response\n        if check_is_empty and not self.is_config_empty(\n            self.write_command(\"show running-config\")\n        ):\n            logger.error(\n                f\"Config not fully unloaded for device {self.destination_device.hostname}\"\n            )\n            return\n        logger.info(\n            f\"Config unloading effort finished for device {self.destination_device.hostname}\"\n        )\n\n    def is_config_empty(\n        self, configuration: str, except_lines: Optional[List[str]] = None\n    ) -&gt; bool:\n        \"\"\"\n        Checks if the configuration of the device is fully empty and return boolean.\n        \"\"\"\n        config_lines = configuration.split(\"\\n\")\n        if (\n            \"show running-config\" not in config_lines[0]\n            or \"localhost#\" not in config_lines[-1]\n        ):\n            logger.debug(f\"Returned config is not okay: {config_lines}\")\n            return False\n\n        # Remove lines that should not be checked (lines in `except_lines` list)\n        config_lines = [\n            line\n            for line in config_lines\n            if all(exception not in line for exception in except_lines)\n        ]\n\n        # Ensure empty interfaces pattern\n        interface_lines = config_lines[1:-1]\n        for i in range(len(interface_lines)):\n            if i % 2 == 0:\n                line = interface_lines[i].split()\n                if (\n                    line[0] != \"interface\"\n                    or line[1] not in self.destination_device.PHYSICAL_INTERFACES_LIST\n                ):\n                    return False\n            else:\n                if \"exit\" not in interface_lines[i]:\n                    return False\n        return True\n\n    @check_connection\n    def ping(self, ip: str, nbr_packets: int = 1, ping_timeout: int = 1) -&gt; str:\n        \"\"\"\n        Sends a ping command to a specified IP address from the device.\n        Supports both Linux and OneOS devices.\n        \"\"\"\n        if self.destination_device.type == \"oneos\":\n            response = self.write_command(\n                f\"ping {ip} -n {nbr_packets} -w {ping_timeout}\"\n            )\n            logger.info(f\"Ping {nbr_packets * 5} packets at IP: {ip}\")\n            return response\n        elif self.destination_device.type == \"linux\":\n            response = self.write_command(\n                f\"ping {ip} -c {nbr_packets} -W {ping_timeout}\"\n            )\n            logger.info(f\"Ping {nbr_packets} packets at IP: {ip}\")\n            return response\n        else:\n            raise NotImplementedError(\n                f\"Ping not implemented for device type {self.destination_device.type}\"\n            )\n\n    @check_device_type(\"linux\")\n    def hping3(\n        self,\n        destination_ip: str,\n        nbr_packets: Optional[int] = None,\n        interval: Optional[str] = None,\n        flood: bool = False,\n        port: Optional[int] = None,\n        type: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Execute hping3 command on the Linux device.\n        For more information about hping3, see https://linux.die.net/man/8/hping3\n        \"\"\"\n        valid_types = [\"tcp\", \"udp\", \"icmp\", \"rawip\", \"syn\", \"ack\", \"fin\", \"rst\"]\n        full_command = \"hping3 \"\n        if nbr_packets is not None:\n            full_command += f\"-c {nbr_packets} \"\n        if interval is not None:\n            full_command += f\"-i {interval} \"\n        if flood:\n            full_command += \"--flood \"\n        if port is not None:\n            full_command += f\"-p {port} \"\n        if type is not None and type.lower() in valid_types:\n            full_command += f\"--{type} \"\n        self.write_command(full_command + destination_ip)\n\n    @check_device_type(\"oneos\")\n    def reconfigure(self, commands_list: List[str]) -&gt; None:\n        \"\"\"\n        Reconfigures a OneOS device with a list of commands.\n        The list of commands is expected to include the exact commands\n            to be sent to the device, with their \"exit\" commands.\n\n        Args:\n            commands_list (List[str]): The list of commands to send to the device, excluding the \"config terminal\" and \"end\" commands.\n\n        Raises:\n            ValueError: If the device is not a OneOS device.\n            ConnectionError: If the device is not connected.\n        \"\"\"\n        logger.debug(\"Reconfiguring device ...\")\n        self.write_command(\"term len 0\")\n        self.write_command(\"config terminal\")\n        for command in commands_list:\n            self.write_command(command)\n        self.write_command(\"end\")\n        self.flush()\n        logger.debug(f\"reconfig commands: {' | '.join(commands_list)}\")\n        logger.info(\"Device reconfigured\")\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection-attributes","title":"Attributes","text":""},{"location":"api/connection/#router_test_kit.connection.Connection.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root: bool\n</code></pre> <p>Checks if the current user is root on a Linux device by writing the 'whoami' command and checking the response.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current user is root, False otherwise.</p>"},{"location":"api/connection/#router_test_kit.connection.Connection-functions","title":"Functions","text":""},{"location":"api/connection/#router_test_kit.connection.Connection.__init__","title":"__init__","text":"<pre><code>__init__(timeout: int = 10)\n</code></pre> <p>Initialize a new connection instance.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Connection timeout in seconds. Defaults to 10.</p> <code>10</code> Note <p>This is an abstract class and should not be instantiated directly. Use concrete implementations like SSHConnection or TelnetConnection.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def __init__(self, timeout: int = 10):\n    \"\"\"Initialize a new connection instance.\n\n    Args:\n        timeout: Connection timeout in seconds. Defaults to 10.\n\n    Note:\n        This is an abstract class and should not be instantiated directly.\n        Use concrete implementations like SSHConnection or TelnetConnection.\n    \"\"\"\n    self.destination_device = None\n    self.destination_ip = None\n    self.resulting_telnet_connection = None\n    self.timeout = timeout\n    self._is_occupied = (\n        False  # Signifies if the connection is in use by another connection\n    )\n    self.prompt_symbol = None\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.connect","title":"connect  <code>abstractmethod</code>","text":"<pre><code>connect(\n    destination_device: Device, destination_ip: str\n) -&gt; Connection\n</code></pre> <p>Establish a connection to the specified device.</p> <p>This method must be implemented by concrete connection classes to establish the actual network connection to the target device.</p> <p>Parameters:</p> Name Type Description Default <code>destination_device</code> <code>Device</code> <p>The device object containing connection credentials</p> required <code>destination_ip</code> <code>str</code> <p>IP address of the target device</p> required <p>Returns:</p> Name Type Description <code>Connection</code> <code>Connection</code> <p>This connection instance for method chaining</p> <p>Raises:</p> Type Description <code>ConnectionAbortedError</code> <p>If the connection cannot be established</p> <code>TimeoutError</code> <p>If the connection attempt times out</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@abstractmethod\ndef connect(self, destination_device: \"Device\", destination_ip: str) -&gt; \"Connection\":\n    \"\"\"Establish a connection to the specified device.\n\n    This method must be implemented by concrete connection classes to establish\n    the actual network connection to the target device.\n\n    Args:\n        destination_device: The device object containing connection credentials\n        destination_ip: IP address of the target device\n\n    Returns:\n        Connection: This connection instance for method chaining\n\n    Raises:\n        ConnectionAbortedError: If the connection cannot be established\n        TimeoutError: If the connection attempt times out\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.disconnect","title":"disconnect  <code>abstractmethod</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the connection to the remote device.</p> <p>This method must be implemented by concrete connection classes to properly close and clean up the network connection.</p> Note <p>After calling this method, the connection object should not be used for further communication until connect() is called again.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@abstractmethod\ndef disconnect(self) -&gt; None:\n    \"\"\"Close the connection to the remote device.\n\n    This method must be implemented by concrete connection classes to properly\n    close and clean up the network connection.\n\n    Note:\n        After calling this method, the connection object should not be used\n        for further communication until connect() is called again.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.check_occupied","title":"check_occupied","text":"<pre><code>check_occupied(func)\n</code></pre> <p>Decorator to check if the connection is already in use and hence not available.</p> <p>This decorator is used to wrap methods that should not be executed if the connection is already in use.</p> <p>Raises:</p> Type Description <code>ConnectionRefusedError</code> <p>If the connection is already in use.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_occupied(func):\n    \"\"\"\n    Decorator to check if the connection is already in use and hence not available.\n\n    This decorator is used to wrap methods that should not be executed if the connection is already in use.\n\n    Raises:\n        ConnectionRefusedError: If the connection is already in use.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        if self._is_occupied:\n            raise ConnectionRefusedError(\n                \"This connection is already in use. Please close the connections that use it first.\"\n            )\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.check_device_type","title":"check_device_type","text":"<pre><code>check_device_type(required_type, is_root: bool = False)\n</code></pre> <p>Decorator to check the device type and connection privileges before executing a function.</p> <p>Parameters:</p> Name Type Description Default <code>required_type</code> <code>str</code> <p>The required device type for the function to be executed.</p> required <code>is_root</code> <code>bool</code> <p>If True, the function requires root privileges to be executed. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not of the required type.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If root privileges are required but the user does not have them.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_device_type(required_type, is_root: bool = False):\n    \"\"\"\n    Decorator to check the device type and connection privileges before executing a function.\n\n    Args:\n        required_type (str): The required device type for the function to be executed.\n        is_root (bool, optional): If True, the function requires root privileges to be executed. Defaults to False.\n\n    Raises:\n        ValueError: If the device is not of the required type.\n        ConnectionError: If the device is not connected.\n        PermissionError: If root privileges are required but the user does not have them.\n    \"\"\"\n\n    def decorator(func):\n        def wrapper(self, *args, **kwargs):\n            if self.destination_device.type != required_type:\n                raise ValueError(\n                    f'This method is available only for {required_type} devices, but the destination device is of type \"{self.destination_device.type}\".'\n                )\n            # Perform the connection check too, since it's a common requirement\n            if not self.is_connected:\n                raise ConnectionError(\"Device is not connected\")\n            if is_root and not self.is_root:\n                raise PermissionError(\n                    \"Root privileges required to perform this action\"\n                )\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.check_connection","title":"check_connection","text":"<pre><code>check_connection(func)\n</code></pre> <p>Decorator to check if the device is connected before executing a function.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_connection(func):\n    \"\"\"\n    Decorator to check if the device is connected before executing a function.\n\n    Raises:\n        ConnectionError: If the device is not connected.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        if not self.is_connected:\n            raise ConnectionError(\"Device is not connected\")\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.write_command","title":"write_command","text":"<pre><code>write_command(\n    command: str,\n    expected_prompt_pattern: Optional[List[str]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Optional[str]\n</code></pre> <p>Writes a command to the telnet connection and returns the response.</p> <p>This method sends a command to the device via the telnet connection, waits for a response, and then returns that response. The response is expected to end with a prompt symbol or match an expected pattern, which is specified by the <code>expected_prompt_pattern</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to be sent to the device.</p> required <code>expected_prompt_pattern</code> <code>Optional[List[str]]</code> <p>A list of regex patterns that the response is expected to match. If None, the method waits for the prompt symbol. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>The maximum time to wait for a response, in seconds. If None, the method uses the default timeout. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The response from the device, or None if there was no response.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the telnet connection is not established.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef write_command(\n    self,\n    command: str,\n    expected_prompt_pattern: Optional[List[str]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Optional[str]:\n    \"\"\"\n    Writes a command to the telnet connection and returns the response.\n\n    This method sends a command to the device via the telnet connection, waits for a response, and then returns that response.\n    The response is expected to end with a prompt symbol or match an expected pattern, which is specified by the `expected_prompt_pattern` parameter.\n\n    Args:\n        command (str): The command to be sent to the device.\n        expected_prompt_pattern (Optional[List[str]]): A list of regex patterns that the response is expected to match. If None, the method waits for the prompt symbol. Defaults to None.\n        timeout (Optional[int]): The maximum time to wait for a response, in seconds. If None, the method uses the default timeout. Defaults to None.\n\n    Returns:\n        Optional[str]: The response from the device, or None if there was no response.\n\n    Raises:\n        ConnectionError: If the telnet connection is not established.\n    \"\"\"\n    self.flush()  # Make sure nothing is in the buffer\n\n    if self.resulting_telnet_connection is not None:\n        # If the command is a string, encode it to bytes first\n        command = (\n            command.encode(\"ascii\") + b\"\\r\"\n            if hasattr(command, \"encode\")\n            else command\n        )\n        self.resulting_telnet_connection.write(command)\n        assert self.prompt_symbol is not None, \"Prompt symbol is not defined.\"\n\n        # \"expect\" can wait for multiple patterns\n        if expected_prompt_pattern:\n            response = self.resulting_telnet_connection.expect(\n                expected_prompt_pattern,\n                timeout or self.timeout,\n            )[2]  # The third element of the tuple is the response\n        # but \"read_until\", while only for one pattern (prompt_symbol), is more reliable\n        else:\n            response = self.resulting_telnet_connection.read_until(\n                self.prompt_symbol.encode(\"ascii\"), timeout or self.timeout\n            )\n        response = response.decode(\"ascii\") if response else None\n    else:\n        raise ConnectionError(\n            \"No connection object from Telnet found during write_command.\"\n        )\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.flush","title":"flush","text":"<pre><code>flush(time_interval: int = 0.1) -&gt; None\n</code></pre> <p>This method waits for a short period of time to allow any remaining data to arrive, then reads and discards all data that has arrived at the telnet connection.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef flush(self, time_interval: int = 0.1) -&gt; None:\n    \"\"\"\n    This method waits for a short period of time to allow any remaining data to arrive,\n    then reads and discards all data that has arrived at the telnet connection.\n    \"\"\"\n    try:\n        time.sleep(time_interval)\n        if self.resulting_telnet_connection is not None:\n            self.resulting_telnet_connection.read_very_eager()\n    except EOFError as eof:\n        logger.error(\n            f\"EOFError. Usually something is wrong while loading the connection. | {eof}\"\n        )\n        raise EOFError from eof\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.read_until","title":"read_until","text":"<pre><code>read_until(\n    prompt: bytes, timeout: Optional[int] = None\n) -&gt; Optional[str]\n</code></pre> <p>Reads data from the telnet connection until a specified prompt is encountered or until timeout.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>bytes</code> <p>The prompt to read until.</p> required <code>timeout</code> <code>Optional[int]</code> <p>The maximum time to wait for the prompt, in seconds. If None, the method uses the default timeout. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The data read from the connection, or None if no data was read.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef read_until(self, prompt: bytes, timeout: Optional[int] = None) -&gt; Optional[str]:\n    \"\"\"\n    Reads data from the telnet connection until a specified prompt is encountered or until timeout.\n\n    Args:\n        prompt (bytes): The prompt to read until.\n        timeout (Optional[int]): The maximum time to wait for the prompt, in seconds. If None, the method uses the default timeout. Defaults to None.\n\n    Returns:\n        Optional[str]: The data read from the connection, or None if no data was read.\n    \"\"\"\n    if timeout is not None:\n        self.timeout = timeout\n    if self.resulting_telnet_connection is not None:\n        response = self.resulting_telnet_connection.read_until(prompt, self.timeout)\n        response = response.decode(\"ascii\") if response else None\n    else:\n        raise NotImplementedError(\n            \"No connection object from Telnet found during read_until.\"\n        )\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.load_config","title":"load_config","text":"<pre><code>load_config(config_path: str) -&gt; None\n</code></pre> <p>Loads a configuration file to a OneOS device.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>The path to the configuration file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a OneOS device.</p> <code>OSError</code> <p>If the configuration file fails to open (might not exist).</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef load_config(self, config_path: str) -&gt; None:\n    \"\"\"\n    Loads a configuration file to a OneOS device.\n\n    Args:\n        config_path (str): The path to the configuration file.\n\n    Raises:\n        ValueError: If the device is not a OneOS device.\n        OSError: If the configuration file fails to open (might not exist).\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(f\"Loading config {config_path.split('/')[-1]} ...\")\n    self.write_command(\"term len 0\")\n    with open(config_path) as fp:\n        for line in fp:\n            if line.strip().startswith(\"!\"):\n                continue  # Skip comment lines\n            if \"hostname\" in line:\n                self.destination_device.hostname = line.split()[-1]\n            response = self.write_command(line)\n\n    # Check that prompt has exited config terminal fully. Search for \"localhost#\" (default) or \"&lt;configured_hostname&gt;#\"\n    self.prompt_symbol = f\"{self.destination_device.hostname}#\"\n    response = self.write_command(\"\\n\").strip()\n    if response != self.prompt_symbol:\n        logger.warning(\n            f\"Loading config might have failed, prompt is not as expected. Received {response} but expected {self.prompt_symbol} instead\"\n        )\n        logger.debug(\n            'Sometimes the developer has miscalculated the \"exit\" commands in the BSA'\n        )\n        self.write_command(\"end\")\n    logger.info(\n        f\"Loaded configuration to device {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.set_sudo","title":"set_sudo","text":"<pre><code>set_sudo(root_password: Optional[str] = None) -&gt; None\n</code></pre> <p>Sets sudo privileges for a Linux device. The prompt symbol is updated to '#' to reflect the change to the root user.</p> <p>Parameters:</p> Name Type Description Default <code>root_password</code> <code>Optional[str]</code> <p>The root password. If None, the method uses the password of the destination device. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a Linux device.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>AssertionError</code> <p>If the method fails to switch to the root user.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\")\ndef set_sudo(self, root_password: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Sets sudo privileges for a Linux device.\n    The prompt symbol is updated to '#' to reflect the change to the root user.\n\n    Args:\n        root_password (Optional[str]): The root password. If None, the method uses the password of the destination device. Defaults to None.\n\n    Raises:\n        ValueError: If the device is not a Linux device.\n        ConnectionError: If the device is not connected.\n        AssertionError: If the method fails to switch to the root user.\n    \"\"\"\n    if root_password is None:\n        root_password = self.destination_device.password\n    self.write_command(\"sudo su\", expected_prompt_pattern=[b\"password for user:\"])\n    self.write_command(root_password, expected_prompt_pattern=[b\"#\"])\n    self.prompt_symbol = \"#\"  # In Linux, changes from '$' to '#' if root\n    assert self.is_root, \"Failed to identify root user\"\n    logger.info(\n        f\"Sudo privileges set for linux device: {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.set_interface_ip","title":"set_interface_ip","text":"<pre><code>set_interface_ip(\n    interface_name: str,\n    ip_addr: str,\n    netmask: str = \"24\",\n    interface_state: str = \"up\",\n) -&gt; None\n</code></pre> <p>Sets the IP address, netmask, and state of a specified interface on a Linux device.</p> <p>Parameters:</p> Name Type Description Default <code>interface_name</code> <code>str</code> <p>The name of the interface.</p> required <code>ip_addr</code> <code>str</code> <p>The IP address to set.</p> required <code>netmask</code> <code>str</code> <p>The netmask to set. Defaults to \"24\".</p> <code>'24'</code> <code>interface_state</code> <code>str</code> <p>The state of the interface. Must be 'up' or 'down'. Defaults to \"up\".</p> <code>'up'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the IP address is invalid, if the interface does not exist or if the device type is not Linux.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If the user does not have root privileges.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\", is_root=True)\ndef set_interface_ip(\n    self,\n    interface_name: str,\n    ip_addr: str,\n    netmask: str = \"24\",\n    interface_state: str = \"up\",\n) -&gt; None:\n    \"\"\"\n    Sets the IP address, netmask, and state of a specified interface on a Linux device.\n\n    Args:\n        interface_name (str): The name of the interface.\n        ip_addr (str): The IP address to set.\n        netmask (str, optional): The netmask to set. Defaults to \"24\".\n        interface_state (str, optional): The state of the interface. Must be 'up' or 'down'. Defaults to \"up\".\n\n    Raises:\n        ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n        ConnectionError: If the device is not connected.\n        PermissionError: If the user does not have root privileges.\n    \"\"\"\n    if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n        raise ValueError(\"Invalid IP address.\")\n    if interface_state not in [\"up\", \"down\"]:\n        logger.error(\n            f\"Invalid state: {interface_state}. Must be 'up' or 'down'. Passing 'up' by default.\"\n        )\n        interface_state = \"up\"\n    if self._get_interface(interface_name) is None:\n        raise ValueError(f\"Interface {interface_name} not found\")\n    self.write_command(f\"ip addr add {ip_addr}/{netmask} dev {interface_name}\")\n    self.write_command(f\"ip link set {interface_name} {interface_state}\")\n    logger.info(\n        f\"Interface {interface_name} set to IP {ip_addr} with netmask {netmask} and state {interface_state}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.delete_interface_ip","title":"delete_interface_ip","text":"<pre><code>delete_interface_ip(\n    interface_name: str, ip_addr: str, netmask: str = \"24\"\n) -&gt; None\n</code></pre> <p>Deletes the IP address from a specified interface on a Linux device.</p> <p>Parameters:</p> Name Type Description Default <code>interface_name</code> <code>str</code> <p>The name of the interface.</p> required <code>ip_addr</code> <code>str</code> <p>The IP address to delete.</p> required <code>netmask</code> <code>str</code> <p>The netmask of the IP address. Defaults to \"24\".</p> <code>'24'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the IP address is invalid, if the interface does not exist or if the device type is not Linux.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If the user does not have root privileges.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\", is_root=True)\ndef delete_interface_ip(\n    self, interface_name: str, ip_addr: str, netmask: str = \"24\"\n) -&gt; None:\n    \"\"\"\n    Deletes the IP address from a specified interface on a Linux device.\n\n    Args:\n        interface_name (str): The name of the interface.\n        ip_addr (str): The IP address to delete.\n        netmask (str, optional): The netmask of the IP address. Defaults to \"24\".\n\n    Raises:\n        ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n        ConnectionError: If the device is not connected.\n        PermissionError: If the user does not have root privileges.\n    \"\"\"\n    if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n        raise ValueError(\"Invalid IP address.\")\n    if self._get_interface(interface_name) is None:\n        raise ValueError(f\"Interface {interface_name} not found\")\n    self.write_command(f\"ip addr del {ip_addr}/{netmask} dev {interface_name}\")\n    logger.info(\n        f\"IP {ip_addr} with netmask {netmask} deleted from interface {interface_name}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.unload_interface","title":"unload_interface","text":"<pre><code>unload_interface(\n    interface_line: str, wrap_command: bool = True\n) -&gt; Optional[str]\n</code></pre> <p>Resets the configuration of a specified interface to its default settings. OneOS6 WARNING: \"By configuring the interface back to default, it is possible that some services will not work any more\"</p> <p>Parameters:</p> Name Type Description Default <code>interface_line</code> <code>str</code> <p>The line of the full interface name to reset (i.e. interface gigabitethernet 0/0).</p> required <code>wrap_command</code> <code>bool</code> <p>If True, the method enters and exits the \"configure terminal\" command.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The response from the device after sending the 'default' command, or None if there was no response.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef unload_interface(\n    self, interface_line: str, wrap_command: bool = True\n) -&gt; Optional[str]:\n    \"\"\"\n    Resets the configuration of a specified interface to its default settings.\n    OneOS6 WARNING: \"By configuring the interface back to default, it is possible that some services will not work any more\"\n\n    Args:\n        interface_line (str): The line of the full interface name to reset (i.e. interface gigabitethernet 0/0).\n        wrap_command (bool, optional): If True, the method enters and exits the \"configure terminal\" command.\n\n    Returns:\n        Optional[str]: The response from the device after sending the 'default' command, or None if there was no response.\n    \"\"\"\n    self.write_command(\"config terminal\") if wrap_command else None\n    response = self.write_command(f\"default {interface_line}\")\n    self.write_command(\"end\") if wrap_command else None\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.unload_config","title":"unload_config","text":"<pre><code>unload_config(\n    unload_specific_commands: Optional[List[str]] = None,\n    check_is_empty: bool = False,\n) -&gt; None\n</code></pre> <p>Unloads the configuration of the device using a bottom-up approach. The configurations on the bottom of the config inherit properties from the configurations above them.</p> <p>Sometimes, even by that approach, some commands cannot be unloaded. In that case, the user must manually unload them,     by providing the no-commands in the unload_specific_commands parameter.</p> <p>The config is retrieved by the very slow \"show running-config\" command. If check_is_empty is True,     \"show running-config\" is called again (another couple of seconds wait time), that's why default is to not check.</p> <p>Parameters:</p> Name Type Description Default <code>unload_specific_commands</code> <code>Optional[List[str]]</code> <p>A list of specific commands to unload. Defaults to None.</p> <code>None</code> <code>check_is_empty</code> <code>bool</code> <p>If True, the method checks if the configuration is empty after unloading. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration is not fully unloaded and check_is_empty is True, or if device type is not oneos.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef unload_config(\n    self,\n    unload_specific_commands: Optional[List[str]] = None,\n    check_is_empty: bool = False,\n) -&gt; None:\n    \"\"\"\n    Unloads the configuration of the device using a bottom-up approach.\n    The configurations on the bottom of the config inherit properties from the configurations above them.\n\n    Sometimes, even by that approach, some commands cannot be unloaded. In that case, the user must manually unload them,\n        by providing the no-commands in the unload_specific_commands parameter.\n\n    The config is retrieved by the very slow \"show running-config\" command. If check_is_empty is True,\n        \"show running-config\" is called again (another couple of seconds wait time), that's why default is to not check.\n\n    Args:\n        unload_specific_commands (Optional[List[str]]): A list of specific commands to unload. Defaults to None.\n        check_is_empty (bool, optional): If True, the method checks if the configuration is empty after unloading. Defaults to False.\n\n    Raises:\n        ValueError: If the configuration is not fully unloaded and check_is_empty is True, or if device type is not oneos.\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(\n        f\"Unloading config for device {self.destination_device.hostname} ...\"\n    )\n    self.write_command(\"term len 0\")\n    self.flush()\n\n    config_lines = self.write_command(\"show running-config\").split(\"\\n\")\n    config_lines_reverse = config_lines[::-1]  # Traverse from bottom to top\n\n    self.prompt_symbol = \"#\"\n    self.write_command(\"config terminal\")\n\n    # Unload ip routes\n    for line in config_lines_reverse:\n        if re.search(r\"^(ip(v6|) (route|host)|aaa authentication login)\", line):\n            self.write_command(f\"no {line}\")\n        elif re.search(r\"^radius-server\", line):\n            self.write_command(f\"no radius-server {line.split(' ')[1]}\")\n        if \"exit\" in line:\n            break\n\n    # Unload interfaces\n    for line in config_lines_reverse:\n        if line.startswith(\"interface\"):\n            # If any of the interfaces listed in permanent_interfaces is a substring of the line\n            if any(\n                interface in line\n                for interface in self.destination_device.PHYSICAL_INTERFACES_LIST\n            ):\n                self.unload_interface(line, wrap_command=False)\n            else:\n                self.write_command(f\"no {line}\")\n\n    # Get all the lines until the first interface\n    interface_index = next(\n        (i for i, line in enumerate(config_lines) if line.startswith(\"interface\")),\n        None,\n    )\n    config_lines_until_interfaces = config_lines[:interface_index]\n    # Get all the lines that are not preceded with space -&gt; assumes that they are unloaded as part of the main line unload\n    main_lines = [\n        line\n        for line in config_lines_until_interfaces\n        if (not line.startswith(\" \") and \"exit\" not in line)\n    ]\n    for line in main_lines[:1:-1]:  # Traverse from bottom to top again\n        if \"license activate\" in line:\n            continue\n        # NOTE: Ignore cases that the \"no\" prefix will not work, expect the user to manually unload these in the loop below\n        self.write_command(f\"no {line}\")\n\n    # Finally, if user knows that there are configuration leftovers, unload it manually\n    if unload_specific_commands is not None:\n        for command in unload_specific_commands:\n            self.write_command(command)\n\n    self.write_command(\"hostname localhost\")\n    self.write_command(\"end\")\n    self.flush()\n\n    # NOTE: By default, keep check to False because \"show running-config\" takes ~4s to return response\n    if check_is_empty and not self.is_config_empty(\n        self.write_command(\"show running-config\")\n    ):\n        logger.error(\n            f\"Config not fully unloaded for device {self.destination_device.hostname}\"\n        )\n        return\n    logger.info(\n        f\"Config unloading effort finished for device {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.is_config_empty","title":"is_config_empty","text":"<pre><code>is_config_empty(\n    configuration: str,\n    except_lines: Optional[List[str]] = None,\n) -&gt; bool\n</code></pre> <p>Checks if the configuration of the device is fully empty and return boolean.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def is_config_empty(\n    self, configuration: str, except_lines: Optional[List[str]] = None\n) -&gt; bool:\n    \"\"\"\n    Checks if the configuration of the device is fully empty and return boolean.\n    \"\"\"\n    config_lines = configuration.split(\"\\n\")\n    if (\n        \"show running-config\" not in config_lines[0]\n        or \"localhost#\" not in config_lines[-1]\n    ):\n        logger.debug(f\"Returned config is not okay: {config_lines}\")\n        return False\n\n    # Remove lines that should not be checked (lines in `except_lines` list)\n    config_lines = [\n        line\n        for line in config_lines\n        if all(exception not in line for exception in except_lines)\n    ]\n\n    # Ensure empty interfaces pattern\n    interface_lines = config_lines[1:-1]\n    for i in range(len(interface_lines)):\n        if i % 2 == 0:\n            line = interface_lines[i].split()\n            if (\n                line[0] != \"interface\"\n                or line[1] not in self.destination_device.PHYSICAL_INTERFACES_LIST\n            ):\n                return False\n        else:\n            if \"exit\" not in interface_lines[i]:\n                return False\n    return True\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.ping","title":"ping","text":"<pre><code>ping(\n    ip: str, nbr_packets: int = 1, ping_timeout: int = 1\n) -&gt; str\n</code></pre> <p>Sends a ping command to a specified IP address from the device. Supports both Linux and OneOS devices.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_connection\ndef ping(self, ip: str, nbr_packets: int = 1, ping_timeout: int = 1) -&gt; str:\n    \"\"\"\n    Sends a ping command to a specified IP address from the device.\n    Supports both Linux and OneOS devices.\n    \"\"\"\n    if self.destination_device.type == \"oneos\":\n        response = self.write_command(\n            f\"ping {ip} -n {nbr_packets} -w {ping_timeout}\"\n        )\n        logger.info(f\"Ping {nbr_packets * 5} packets at IP: {ip}\")\n        return response\n    elif self.destination_device.type == \"linux\":\n        response = self.write_command(\n            f\"ping {ip} -c {nbr_packets} -W {ping_timeout}\"\n        )\n        logger.info(f\"Ping {nbr_packets} packets at IP: {ip}\")\n        return response\n    else:\n        raise NotImplementedError(\n            f\"Ping not implemented for device type {self.destination_device.type}\"\n        )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.hping3","title":"hping3","text":"<pre><code>hping3(\n    destination_ip: str,\n    nbr_packets: Optional[int] = None,\n    interval: Optional[str] = None,\n    flood: bool = False,\n    port: Optional[int] = None,\n    type: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Execute hping3 command on the Linux device. For more information about hping3, see https://linux.die.net/man/8/hping3</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\")\ndef hping3(\n    self,\n    destination_ip: str,\n    nbr_packets: Optional[int] = None,\n    interval: Optional[str] = None,\n    flood: bool = False,\n    port: Optional[int] = None,\n    type: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Execute hping3 command on the Linux device.\n    For more information about hping3, see https://linux.die.net/man/8/hping3\n    \"\"\"\n    valid_types = [\"tcp\", \"udp\", \"icmp\", \"rawip\", \"syn\", \"ack\", \"fin\", \"rst\"]\n    full_command = \"hping3 \"\n    if nbr_packets is not None:\n        full_command += f\"-c {nbr_packets} \"\n    if interval is not None:\n        full_command += f\"-i {interval} \"\n    if flood:\n        full_command += \"--flood \"\n    if port is not None:\n        full_command += f\"-p {port} \"\n    if type is not None and type.lower() in valid_types:\n        full_command += f\"--{type} \"\n    self.write_command(full_command + destination_ip)\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.Connection.reconfigure","title":"reconfigure","text":"<pre><code>reconfigure(commands_list: List[str]) -&gt; None\n</code></pre> <p>Reconfigures a OneOS device with a list of commands. The list of commands is expected to include the exact commands     to be sent to the device, with their \"exit\" commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands_list</code> <code>List[str]</code> <p>The list of commands to send to the device, excluding the \"config terminal\" and \"end\" commands.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a OneOS device.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef reconfigure(self, commands_list: List[str]) -&gt; None:\n    \"\"\"\n    Reconfigures a OneOS device with a list of commands.\n    The list of commands is expected to include the exact commands\n        to be sent to the device, with their \"exit\" commands.\n\n    Args:\n        commands_list (List[str]): The list of commands to send to the device, excluding the \"config terminal\" and \"end\" commands.\n\n    Raises:\n        ValueError: If the device is not a OneOS device.\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(\"Reconfiguring device ...\")\n    self.write_command(\"term len 0\")\n    self.write_command(\"config terminal\")\n    for command in commands_list:\n        self.write_command(command)\n    self.write_command(\"end\")\n    self.flush()\n    logger.debug(f\"reconfig commands: {' | '.join(commands_list)}\")\n    logger.info(\"Device reconfigured\")\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection","title":"SSHConnection","text":"<p>               Bases: <code>Connection</code></p> <p>Represents a secure SSH connection to a remote device. This is the recommended secure alternative to TelnetConnection.</p> <p>Uses the paramiko library to establish and manage secure SSH connections. Supports both password authentication and key-based authentication.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>class SSHConnection(Connection):\n    \"\"\"\n    Represents a secure SSH connection to a remote device.\n    This is the recommended secure alternative to TelnetConnection.\n\n    Uses the paramiko library to establish and manage secure SSH connections.\n    Supports both password authentication and key-based authentication.\n    \"\"\"\n\n    def __init__(self, timeout: int = 10):\n        super().__init__(timeout)\n        self.ssh_client: Optional[paramiko.SSHClient] = None\n        self.ssh_channel: Optional[paramiko.Channel] = None\n\n    @Connection.check_occupied\n    def connect(self, destination_device: \"Device\", destination_ip: str) -&gt; \"Connection\":\n        \"\"\"\n        Establishes an SSH connection to the destination device.\n\n        Args:\n            destination_device (Device): The device object containing credentials\n            destination_ip (str): The IP address of the destination device\n\n        Returns:\n            Connection: This connection object for method chaining\n\n        Raises:\n            ConnectionAbortedError: If the SSH connection could not be established\n        \"\"\"\n        self.prompt_symbol = destination_device.DEFAULT_PROMPT_SYMBOL\n        self.destination_device = destination_device\n        self.destination_ip = destination_ip\n\n        try:\n            # Create SSH client\n            self.ssh_client = paramiko.SSHClient()\n            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n            # Connect to the device\n            self.ssh_client.connect(\n                hostname=destination_ip,\n                username=destination_device.username,\n                password=destination_device.password,\n                timeout=self.timeout,\n                look_for_keys=False,  # Don't look for SSH keys unless specifically configured\n                allow_agent=False     # Don't use SSH agent\n            )\n\n            # Create an interactive shell channel\n            self.ssh_channel = self.ssh_client.invoke_shell()\n            self.ssh_channel.settimeout(self.timeout)\n\n            # Wait for initial prompt and flush any welcome messages\n            time.sleep(0.5)  # Give device time to send welcome message\n            self._flush_channel()\n\n            if not self.is_connected:\n                raise ConnectionAbortedError(\"SSH connection established but channel failed\")\n\n            logger.info(f\"SSH connected to {self.destination_device.hostname} at {self.destination_ip}\")\n            return self\n\n        except Exception as e:\n            if self.ssh_client:\n                self.ssh_client.close()\n            raise ConnectionAbortedError(f\"SSH connection failed: {str(e)}\") from e\n\n    def _flush_channel(self) -&gt; None:\n        \"\"\"Flush any pending data from the SSH channel.\"\"\"\n        if self.ssh_channel and self.ssh_channel.recv_ready():\n            try:\n                self.ssh_channel.recv(4096)\n            except socket.timeout:\n                pass  # Expected when no data available\n\n    @Connection.check_occupied\n    def disconnect(self) -&gt; None:\n        \"\"\"Closes the SSH connection and channel.\"\"\"\n        if self.ssh_channel:\n            self.ssh_channel.close()\n            self.ssh_channel = None\n\n        if self.ssh_client:\n            self.ssh_client.close()\n            self.ssh_client = None\n\n        if self.is_connected:\n            raise ConnectionError(\"SSH connection could not be closed\")\n\n        logger.info(f\"SSH disconnected from {self.destination_device.hostname} at {self.destination_ip}\")\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if the SSH connection and channel are active.\"\"\"\n        return (\n            self.ssh_client is not None\n            and self.ssh_channel is not None\n            and not self.ssh_channel.closed\n            and self.ssh_client.get_transport() is not None\n            and self.ssh_client.get_transport().is_active()\n        )\n\n    @Connection.check_occupied\n    def write_command(\n        self,\n        command: str,\n        expected_prompt_pattern: Optional[List[str]] = None,\n        timeout: Optional[int] = None,\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Sends a command via SSH and returns the response.\n\n        Args:\n            command (str): The command to send\n            expected_prompt_pattern (Optional[List[str]]): Regex patterns to wait for\n            timeout (Optional[int]): Timeout in seconds\n\n        Returns:\n            Optional[str]: The command response\n\n        Raises:\n            ConnectionError: If SSH connection is not established\n        \"\"\"\n        if not self.is_connected:\n            raise ConnectionError(\"SSH connection is not established\")\n\n        if self.ssh_channel is None:\n            raise ConnectionError(\"SSH channel is not available\")\n\n        # Clear any pending data\n        self._flush_channel()\n\n        # Send the command\n        command_with_newline = command + \"\\n\"\n        self.ssh_channel.send(command_with_newline.encode('utf-8'))\n\n        # Read the response\n        response_parts = []\n        command_timeout = timeout or self.timeout\n        start_time = time.time()\n\n        while True:\n            if time.time() - start_time &gt; command_timeout:\n                logger.warning(f\"Command '{command}' timed out after {command_timeout} seconds\")\n                break\n\n            if self.ssh_channel.recv_ready():\n                try:\n                    data = self.ssh_channel.recv(4096).decode('utf-8')\n                    response_parts.append(data)\n\n                    # Check if we have a complete response\n                    full_response = ''.join(response_parts)\n\n                    if expected_prompt_pattern:\n                        # Check against expected patterns\n                        for pattern in expected_prompt_pattern:\n                            if re.search(pattern, full_response):\n                                return full_response\n                    else:\n                        # Check for prompt symbol\n                        if self.prompt_symbol and self.prompt_symbol in full_response:\n                            return full_response\n\n                except socket.timeout:\n                    continue\n                except Exception as e:\n                    logger.error(f\"Error reading SSH response: {e}\")\n                    break\n            else:\n                time.sleep(0.1)\n\n        return ''.join(response_parts) if response_parts else None\n\n    @Connection.check_occupied\n    def flush(self, time_interval: float = 0.1) -&gt; None:\n        \"\"\"Flush any pending data from the SSH channel.\"\"\"\n        time.sleep(time_interval)\n        self._flush_channel()\n\n    @Connection.check_occupied\n    def flush_deep(self, time_interval: float = 0.1, retries_timeout: int = 60) -&gt; None:\n        \"\"\"Perform deep flush with retries until prompt appears.\"\"\"\n        logger.debug(\"SSH deep flushing...\")\n        start_time = time.time()\n\n        while True:\n            self.flush(time_interval)\n\n            # Try to get current prompt\n            if self.ssh_channel and self.ssh_channel.recv_ready():\n                try:\n                    data = self.ssh_channel.recv(1024).decode('utf-8')\n                    if self.prompt_symbol and self.prompt_symbol in data:\n                        break\n                except:\n                    pass\n\n            if retries_timeout &gt; 0 and time.time() - start_time &gt; retries_timeout:\n                logger.warning(f\"Deep flush timed out after {retries_timeout} seconds\")\n                break\n\n            time.sleep(time_interval)\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection-attributes","title":"Attributes","text":""},{"location":"api/connection/#router_test_kit.connection.SSHConnection.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Check if the SSH connection and channel are active.</p>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root: bool\n</code></pre> <p>Checks if the current user is root on a Linux device by writing the 'whoami' command and checking the response.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current user is root, False otherwise.</p>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection-functions","title":"Functions","text":""},{"location":"api/connection/#router_test_kit.connection.SSHConnection.connect","title":"connect","text":"<pre><code>connect(\n    destination_device: Device, destination_ip: str\n) -&gt; Connection\n</code></pre> <p>Establishes an SSH connection to the destination device.</p> <p>Parameters:</p> Name Type Description Default <code>destination_device</code> <code>Device</code> <p>The device object containing credentials</p> required <code>destination_ip</code> <code>str</code> <p>The IP address of the destination device</p> required <p>Returns:</p> Name Type Description <code>Connection</code> <code>Connection</code> <p>This connection object for method chaining</p> <p>Raises:</p> Type Description <code>ConnectionAbortedError</code> <p>If the SSH connection could not be established</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@Connection.check_occupied\ndef connect(self, destination_device: \"Device\", destination_ip: str) -&gt; \"Connection\":\n    \"\"\"\n    Establishes an SSH connection to the destination device.\n\n    Args:\n        destination_device (Device): The device object containing credentials\n        destination_ip (str): The IP address of the destination device\n\n    Returns:\n        Connection: This connection object for method chaining\n\n    Raises:\n        ConnectionAbortedError: If the SSH connection could not be established\n    \"\"\"\n    self.prompt_symbol = destination_device.DEFAULT_PROMPT_SYMBOL\n    self.destination_device = destination_device\n    self.destination_ip = destination_ip\n\n    try:\n        # Create SSH client\n        self.ssh_client = paramiko.SSHClient()\n        self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n        # Connect to the device\n        self.ssh_client.connect(\n            hostname=destination_ip,\n            username=destination_device.username,\n            password=destination_device.password,\n            timeout=self.timeout,\n            look_for_keys=False,  # Don't look for SSH keys unless specifically configured\n            allow_agent=False     # Don't use SSH agent\n        )\n\n        # Create an interactive shell channel\n        self.ssh_channel = self.ssh_client.invoke_shell()\n        self.ssh_channel.settimeout(self.timeout)\n\n        # Wait for initial prompt and flush any welcome messages\n        time.sleep(0.5)  # Give device time to send welcome message\n        self._flush_channel()\n\n        if not self.is_connected:\n            raise ConnectionAbortedError(\"SSH connection established but channel failed\")\n\n        logger.info(f\"SSH connected to {self.destination_device.hostname} at {self.destination_ip}\")\n        return self\n\n    except Exception as e:\n        if self.ssh_client:\n            self.ssh_client.close()\n        raise ConnectionAbortedError(f\"SSH connection failed: {str(e)}\") from e\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Closes the SSH connection and channel.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@Connection.check_occupied\ndef disconnect(self) -&gt; None:\n    \"\"\"Closes the SSH connection and channel.\"\"\"\n    if self.ssh_channel:\n        self.ssh_channel.close()\n        self.ssh_channel = None\n\n    if self.ssh_client:\n        self.ssh_client.close()\n        self.ssh_client = None\n\n    if self.is_connected:\n        raise ConnectionError(\"SSH connection could not be closed\")\n\n    logger.info(f\"SSH disconnected from {self.destination_device.hostname} at {self.destination_ip}\")\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.write_command","title":"write_command","text":"<pre><code>write_command(\n    command: str,\n    expected_prompt_pattern: Optional[List[str]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Optional[str]\n</code></pre> <p>Sends a command via SSH and returns the response.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to send</p> required <code>expected_prompt_pattern</code> <code>Optional[List[str]]</code> <p>Regex patterns to wait for</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>Timeout in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The command response</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If SSH connection is not established</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@Connection.check_occupied\ndef write_command(\n    self,\n    command: str,\n    expected_prompt_pattern: Optional[List[str]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Optional[str]:\n    \"\"\"\n    Sends a command via SSH and returns the response.\n\n    Args:\n        command (str): The command to send\n        expected_prompt_pattern (Optional[List[str]]): Regex patterns to wait for\n        timeout (Optional[int]): Timeout in seconds\n\n    Returns:\n        Optional[str]: The command response\n\n    Raises:\n        ConnectionError: If SSH connection is not established\n    \"\"\"\n    if not self.is_connected:\n        raise ConnectionError(\"SSH connection is not established\")\n\n    if self.ssh_channel is None:\n        raise ConnectionError(\"SSH channel is not available\")\n\n    # Clear any pending data\n    self._flush_channel()\n\n    # Send the command\n    command_with_newline = command + \"\\n\"\n    self.ssh_channel.send(command_with_newline.encode('utf-8'))\n\n    # Read the response\n    response_parts = []\n    command_timeout = timeout or self.timeout\n    start_time = time.time()\n\n    while True:\n        if time.time() - start_time &gt; command_timeout:\n            logger.warning(f\"Command '{command}' timed out after {command_timeout} seconds\")\n            break\n\n        if self.ssh_channel.recv_ready():\n            try:\n                data = self.ssh_channel.recv(4096).decode('utf-8')\n                response_parts.append(data)\n\n                # Check if we have a complete response\n                full_response = ''.join(response_parts)\n\n                if expected_prompt_pattern:\n                    # Check against expected patterns\n                    for pattern in expected_prompt_pattern:\n                        if re.search(pattern, full_response):\n                            return full_response\n                else:\n                    # Check for prompt symbol\n                    if self.prompt_symbol and self.prompt_symbol in full_response:\n                        return full_response\n\n            except socket.timeout:\n                continue\n            except Exception as e:\n                logger.error(f\"Error reading SSH response: {e}\")\n                break\n        else:\n            time.sleep(0.1)\n\n    return ''.join(response_parts) if response_parts else None\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.flush","title":"flush","text":"<pre><code>flush(time_interval: float = 0.1) -&gt; None\n</code></pre> <p>Flush any pending data from the SSH channel.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@Connection.check_occupied\ndef flush(self, time_interval: float = 0.1) -&gt; None:\n    \"\"\"Flush any pending data from the SSH channel.\"\"\"\n    time.sleep(time_interval)\n    self._flush_channel()\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.flush_deep","title":"flush_deep","text":"<pre><code>flush_deep(\n    time_interval: float = 0.1, retries_timeout: int = 60\n) -&gt; None\n</code></pre> <p>Perform deep flush with retries until prompt appears.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@Connection.check_occupied\ndef flush_deep(self, time_interval: float = 0.1, retries_timeout: int = 60) -&gt; None:\n    \"\"\"Perform deep flush with retries until prompt appears.\"\"\"\n    logger.debug(\"SSH deep flushing...\")\n    start_time = time.time()\n\n    while True:\n        self.flush(time_interval)\n\n        # Try to get current prompt\n        if self.ssh_channel and self.ssh_channel.recv_ready():\n            try:\n                data = self.ssh_channel.recv(1024).decode('utf-8')\n                if self.prompt_symbol and self.prompt_symbol in data:\n                    break\n            except:\n                pass\n\n        if retries_timeout &gt; 0 and time.time() - start_time &gt; retries_timeout:\n            logger.warning(f\"Deep flush timed out after {retries_timeout} seconds\")\n            break\n\n        time.sleep(time_interval)\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.check_occupied","title":"check_occupied","text":"<pre><code>check_occupied(func)\n</code></pre> <p>Decorator to check if the connection is already in use and hence not available.</p> <p>This decorator is used to wrap methods that should not be executed if the connection is already in use.</p> <p>Raises:</p> Type Description <code>ConnectionRefusedError</code> <p>If the connection is already in use.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_occupied(func):\n    \"\"\"\n    Decorator to check if the connection is already in use and hence not available.\n\n    This decorator is used to wrap methods that should not be executed if the connection is already in use.\n\n    Raises:\n        ConnectionRefusedError: If the connection is already in use.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        if self._is_occupied:\n            raise ConnectionRefusedError(\n                \"This connection is already in use. Please close the connections that use it first.\"\n            )\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.check_device_type","title":"check_device_type","text":"<pre><code>check_device_type(required_type, is_root: bool = False)\n</code></pre> <p>Decorator to check the device type and connection privileges before executing a function.</p> <p>Parameters:</p> Name Type Description Default <code>required_type</code> <code>str</code> <p>The required device type for the function to be executed.</p> required <code>is_root</code> <code>bool</code> <p>If True, the function requires root privileges to be executed. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not of the required type.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If root privileges are required but the user does not have them.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_device_type(required_type, is_root: bool = False):\n    \"\"\"\n    Decorator to check the device type and connection privileges before executing a function.\n\n    Args:\n        required_type (str): The required device type for the function to be executed.\n        is_root (bool, optional): If True, the function requires root privileges to be executed. Defaults to False.\n\n    Raises:\n        ValueError: If the device is not of the required type.\n        ConnectionError: If the device is not connected.\n        PermissionError: If root privileges are required but the user does not have them.\n    \"\"\"\n\n    def decorator(func):\n        def wrapper(self, *args, **kwargs):\n            if self.destination_device.type != required_type:\n                raise ValueError(\n                    f'This method is available only for {required_type} devices, but the destination device is of type \"{self.destination_device.type}\".'\n                )\n            # Perform the connection check too, since it's a common requirement\n            if not self.is_connected:\n                raise ConnectionError(\"Device is not connected\")\n            if is_root and not self.is_root:\n                raise PermissionError(\n                    \"Root privileges required to perform this action\"\n                )\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.check_connection","title":"check_connection","text":"<pre><code>check_connection(func)\n</code></pre> <p>Decorator to check if the device is connected before executing a function.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_connection(func):\n    \"\"\"\n    Decorator to check if the device is connected before executing a function.\n\n    Raises:\n        ConnectionError: If the device is not connected.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        if not self.is_connected:\n            raise ConnectionError(\"Device is not connected\")\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.read_until","title":"read_until","text":"<pre><code>read_until(\n    prompt: bytes, timeout: Optional[int] = None\n) -&gt; Optional[str]\n</code></pre> <p>Reads data from the telnet connection until a specified prompt is encountered or until timeout.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>bytes</code> <p>The prompt to read until.</p> required <code>timeout</code> <code>Optional[int]</code> <p>The maximum time to wait for the prompt, in seconds. If None, the method uses the default timeout. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The data read from the connection, or None if no data was read.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef read_until(self, prompt: bytes, timeout: Optional[int] = None) -&gt; Optional[str]:\n    \"\"\"\n    Reads data from the telnet connection until a specified prompt is encountered or until timeout.\n\n    Args:\n        prompt (bytes): The prompt to read until.\n        timeout (Optional[int]): The maximum time to wait for the prompt, in seconds. If None, the method uses the default timeout. Defaults to None.\n\n    Returns:\n        Optional[str]: The data read from the connection, or None if no data was read.\n    \"\"\"\n    if timeout is not None:\n        self.timeout = timeout\n    if self.resulting_telnet_connection is not None:\n        response = self.resulting_telnet_connection.read_until(prompt, self.timeout)\n        response = response.decode(\"ascii\") if response else None\n    else:\n        raise NotImplementedError(\n            \"No connection object from Telnet found during read_until.\"\n        )\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.load_config","title":"load_config","text":"<pre><code>load_config(config_path: str) -&gt; None\n</code></pre> <p>Loads a configuration file to a OneOS device.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>The path to the configuration file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a OneOS device.</p> <code>OSError</code> <p>If the configuration file fails to open (might not exist).</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef load_config(self, config_path: str) -&gt; None:\n    \"\"\"\n    Loads a configuration file to a OneOS device.\n\n    Args:\n        config_path (str): The path to the configuration file.\n\n    Raises:\n        ValueError: If the device is not a OneOS device.\n        OSError: If the configuration file fails to open (might not exist).\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(f\"Loading config {config_path.split('/')[-1]} ...\")\n    self.write_command(\"term len 0\")\n    with open(config_path) as fp:\n        for line in fp:\n            if line.strip().startswith(\"!\"):\n                continue  # Skip comment lines\n            if \"hostname\" in line:\n                self.destination_device.hostname = line.split()[-1]\n            response = self.write_command(line)\n\n    # Check that prompt has exited config terminal fully. Search for \"localhost#\" (default) or \"&lt;configured_hostname&gt;#\"\n    self.prompt_symbol = f\"{self.destination_device.hostname}#\"\n    response = self.write_command(\"\\n\").strip()\n    if response != self.prompt_symbol:\n        logger.warning(\n            f\"Loading config might have failed, prompt is not as expected. Received {response} but expected {self.prompt_symbol} instead\"\n        )\n        logger.debug(\n            'Sometimes the developer has miscalculated the \"exit\" commands in the BSA'\n        )\n        self.write_command(\"end\")\n    logger.info(\n        f\"Loaded configuration to device {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.set_sudo","title":"set_sudo","text":"<pre><code>set_sudo(root_password: Optional[str] = None) -&gt; None\n</code></pre> <p>Sets sudo privileges for a Linux device. The prompt symbol is updated to '#' to reflect the change to the root user.</p> <p>Parameters:</p> Name Type Description Default <code>root_password</code> <code>Optional[str]</code> <p>The root password. If None, the method uses the password of the destination device. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a Linux device.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>AssertionError</code> <p>If the method fails to switch to the root user.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\")\ndef set_sudo(self, root_password: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Sets sudo privileges for a Linux device.\n    The prompt symbol is updated to '#' to reflect the change to the root user.\n\n    Args:\n        root_password (Optional[str]): The root password. If None, the method uses the password of the destination device. Defaults to None.\n\n    Raises:\n        ValueError: If the device is not a Linux device.\n        ConnectionError: If the device is not connected.\n        AssertionError: If the method fails to switch to the root user.\n    \"\"\"\n    if root_password is None:\n        root_password = self.destination_device.password\n    self.write_command(\"sudo su\", expected_prompt_pattern=[b\"password for user:\"])\n    self.write_command(root_password, expected_prompt_pattern=[b\"#\"])\n    self.prompt_symbol = \"#\"  # In Linux, changes from '$' to '#' if root\n    assert self.is_root, \"Failed to identify root user\"\n    logger.info(\n        f\"Sudo privileges set for linux device: {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.set_interface_ip","title":"set_interface_ip","text":"<pre><code>set_interface_ip(\n    interface_name: str,\n    ip_addr: str,\n    netmask: str = \"24\",\n    interface_state: str = \"up\",\n) -&gt; None\n</code></pre> <p>Sets the IP address, netmask, and state of a specified interface on a Linux device.</p> <p>Parameters:</p> Name Type Description Default <code>interface_name</code> <code>str</code> <p>The name of the interface.</p> required <code>ip_addr</code> <code>str</code> <p>The IP address to set.</p> required <code>netmask</code> <code>str</code> <p>The netmask to set. Defaults to \"24\".</p> <code>'24'</code> <code>interface_state</code> <code>str</code> <p>The state of the interface. Must be 'up' or 'down'. Defaults to \"up\".</p> <code>'up'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the IP address is invalid, if the interface does not exist or if the device type is not Linux.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If the user does not have root privileges.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\", is_root=True)\ndef set_interface_ip(\n    self,\n    interface_name: str,\n    ip_addr: str,\n    netmask: str = \"24\",\n    interface_state: str = \"up\",\n) -&gt; None:\n    \"\"\"\n    Sets the IP address, netmask, and state of a specified interface on a Linux device.\n\n    Args:\n        interface_name (str): The name of the interface.\n        ip_addr (str): The IP address to set.\n        netmask (str, optional): The netmask to set. Defaults to \"24\".\n        interface_state (str, optional): The state of the interface. Must be 'up' or 'down'. Defaults to \"up\".\n\n    Raises:\n        ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n        ConnectionError: If the device is not connected.\n        PermissionError: If the user does not have root privileges.\n    \"\"\"\n    if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n        raise ValueError(\"Invalid IP address.\")\n    if interface_state not in [\"up\", \"down\"]:\n        logger.error(\n            f\"Invalid state: {interface_state}. Must be 'up' or 'down'. Passing 'up' by default.\"\n        )\n        interface_state = \"up\"\n    if self._get_interface(interface_name) is None:\n        raise ValueError(f\"Interface {interface_name} not found\")\n    self.write_command(f\"ip addr add {ip_addr}/{netmask} dev {interface_name}\")\n    self.write_command(f\"ip link set {interface_name} {interface_state}\")\n    logger.info(\n        f\"Interface {interface_name} set to IP {ip_addr} with netmask {netmask} and state {interface_state}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.delete_interface_ip","title":"delete_interface_ip","text":"<pre><code>delete_interface_ip(\n    interface_name: str, ip_addr: str, netmask: str = \"24\"\n) -&gt; None\n</code></pre> <p>Deletes the IP address from a specified interface on a Linux device.</p> <p>Parameters:</p> Name Type Description Default <code>interface_name</code> <code>str</code> <p>The name of the interface.</p> required <code>ip_addr</code> <code>str</code> <p>The IP address to delete.</p> required <code>netmask</code> <code>str</code> <p>The netmask of the IP address. Defaults to \"24\".</p> <code>'24'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the IP address is invalid, if the interface does not exist or if the device type is not Linux.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If the user does not have root privileges.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\", is_root=True)\ndef delete_interface_ip(\n    self, interface_name: str, ip_addr: str, netmask: str = \"24\"\n) -&gt; None:\n    \"\"\"\n    Deletes the IP address from a specified interface on a Linux device.\n\n    Args:\n        interface_name (str): The name of the interface.\n        ip_addr (str): The IP address to delete.\n        netmask (str, optional): The netmask of the IP address. Defaults to \"24\".\n\n    Raises:\n        ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n        ConnectionError: If the device is not connected.\n        PermissionError: If the user does not have root privileges.\n    \"\"\"\n    if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n        raise ValueError(\"Invalid IP address.\")\n    if self._get_interface(interface_name) is None:\n        raise ValueError(f\"Interface {interface_name} not found\")\n    self.write_command(f\"ip addr del {ip_addr}/{netmask} dev {interface_name}\")\n    logger.info(\n        f\"IP {ip_addr} with netmask {netmask} deleted from interface {interface_name}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.unload_interface","title":"unload_interface","text":"<pre><code>unload_interface(\n    interface_line: str, wrap_command: bool = True\n) -&gt; Optional[str]\n</code></pre> <p>Resets the configuration of a specified interface to its default settings. OneOS6 WARNING: \"By configuring the interface back to default, it is possible that some services will not work any more\"</p> <p>Parameters:</p> Name Type Description Default <code>interface_line</code> <code>str</code> <p>The line of the full interface name to reset (i.e. interface gigabitethernet 0/0).</p> required <code>wrap_command</code> <code>bool</code> <p>If True, the method enters and exits the \"configure terminal\" command.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The response from the device after sending the 'default' command, or None if there was no response.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef unload_interface(\n    self, interface_line: str, wrap_command: bool = True\n) -&gt; Optional[str]:\n    \"\"\"\n    Resets the configuration of a specified interface to its default settings.\n    OneOS6 WARNING: \"By configuring the interface back to default, it is possible that some services will not work any more\"\n\n    Args:\n        interface_line (str): The line of the full interface name to reset (i.e. interface gigabitethernet 0/0).\n        wrap_command (bool, optional): If True, the method enters and exits the \"configure terminal\" command.\n\n    Returns:\n        Optional[str]: The response from the device after sending the 'default' command, or None if there was no response.\n    \"\"\"\n    self.write_command(\"config terminal\") if wrap_command else None\n    response = self.write_command(f\"default {interface_line}\")\n    self.write_command(\"end\") if wrap_command else None\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.unload_config","title":"unload_config","text":"<pre><code>unload_config(\n    unload_specific_commands: Optional[List[str]] = None,\n    check_is_empty: bool = False,\n) -&gt; None\n</code></pre> <p>Unloads the configuration of the device using a bottom-up approach. The configurations on the bottom of the config inherit properties from the configurations above them.</p> <p>Sometimes, even by that approach, some commands cannot be unloaded. In that case, the user must manually unload them,     by providing the no-commands in the unload_specific_commands parameter.</p> <p>The config is retrieved by the very slow \"show running-config\" command. If check_is_empty is True,     \"show running-config\" is called again (another couple of seconds wait time), that's why default is to not check.</p> <p>Parameters:</p> Name Type Description Default <code>unload_specific_commands</code> <code>Optional[List[str]]</code> <p>A list of specific commands to unload. Defaults to None.</p> <code>None</code> <code>check_is_empty</code> <code>bool</code> <p>If True, the method checks if the configuration is empty after unloading. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration is not fully unloaded and check_is_empty is True, or if device type is not oneos.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef unload_config(\n    self,\n    unload_specific_commands: Optional[List[str]] = None,\n    check_is_empty: bool = False,\n) -&gt; None:\n    \"\"\"\n    Unloads the configuration of the device using a bottom-up approach.\n    The configurations on the bottom of the config inherit properties from the configurations above them.\n\n    Sometimes, even by that approach, some commands cannot be unloaded. In that case, the user must manually unload them,\n        by providing the no-commands in the unload_specific_commands parameter.\n\n    The config is retrieved by the very slow \"show running-config\" command. If check_is_empty is True,\n        \"show running-config\" is called again (another couple of seconds wait time), that's why default is to not check.\n\n    Args:\n        unload_specific_commands (Optional[List[str]]): A list of specific commands to unload. Defaults to None.\n        check_is_empty (bool, optional): If True, the method checks if the configuration is empty after unloading. Defaults to False.\n\n    Raises:\n        ValueError: If the configuration is not fully unloaded and check_is_empty is True, or if device type is not oneos.\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(\n        f\"Unloading config for device {self.destination_device.hostname} ...\"\n    )\n    self.write_command(\"term len 0\")\n    self.flush()\n\n    config_lines = self.write_command(\"show running-config\").split(\"\\n\")\n    config_lines_reverse = config_lines[::-1]  # Traverse from bottom to top\n\n    self.prompt_symbol = \"#\"\n    self.write_command(\"config terminal\")\n\n    # Unload ip routes\n    for line in config_lines_reverse:\n        if re.search(r\"^(ip(v6|) (route|host)|aaa authentication login)\", line):\n            self.write_command(f\"no {line}\")\n        elif re.search(r\"^radius-server\", line):\n            self.write_command(f\"no radius-server {line.split(' ')[1]}\")\n        if \"exit\" in line:\n            break\n\n    # Unload interfaces\n    for line in config_lines_reverse:\n        if line.startswith(\"interface\"):\n            # If any of the interfaces listed in permanent_interfaces is a substring of the line\n            if any(\n                interface in line\n                for interface in self.destination_device.PHYSICAL_INTERFACES_LIST\n            ):\n                self.unload_interface(line, wrap_command=False)\n            else:\n                self.write_command(f\"no {line}\")\n\n    # Get all the lines until the first interface\n    interface_index = next(\n        (i for i, line in enumerate(config_lines) if line.startswith(\"interface\")),\n        None,\n    )\n    config_lines_until_interfaces = config_lines[:interface_index]\n    # Get all the lines that are not preceded with space -&gt; assumes that they are unloaded as part of the main line unload\n    main_lines = [\n        line\n        for line in config_lines_until_interfaces\n        if (not line.startswith(\" \") and \"exit\" not in line)\n    ]\n    for line in main_lines[:1:-1]:  # Traverse from bottom to top again\n        if \"license activate\" in line:\n            continue\n        # NOTE: Ignore cases that the \"no\" prefix will not work, expect the user to manually unload these in the loop below\n        self.write_command(f\"no {line}\")\n\n    # Finally, if user knows that there are configuration leftovers, unload it manually\n    if unload_specific_commands is not None:\n        for command in unload_specific_commands:\n            self.write_command(command)\n\n    self.write_command(\"hostname localhost\")\n    self.write_command(\"end\")\n    self.flush()\n\n    # NOTE: By default, keep check to False because \"show running-config\" takes ~4s to return response\n    if check_is_empty and not self.is_config_empty(\n        self.write_command(\"show running-config\")\n    ):\n        logger.error(\n            f\"Config not fully unloaded for device {self.destination_device.hostname}\"\n        )\n        return\n    logger.info(\n        f\"Config unloading effort finished for device {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.is_config_empty","title":"is_config_empty","text":"<pre><code>is_config_empty(\n    configuration: str,\n    except_lines: Optional[List[str]] = None,\n) -&gt; bool\n</code></pre> <p>Checks if the configuration of the device is fully empty and return boolean.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def is_config_empty(\n    self, configuration: str, except_lines: Optional[List[str]] = None\n) -&gt; bool:\n    \"\"\"\n    Checks if the configuration of the device is fully empty and return boolean.\n    \"\"\"\n    config_lines = configuration.split(\"\\n\")\n    if (\n        \"show running-config\" not in config_lines[0]\n        or \"localhost#\" not in config_lines[-1]\n    ):\n        logger.debug(f\"Returned config is not okay: {config_lines}\")\n        return False\n\n    # Remove lines that should not be checked (lines in `except_lines` list)\n    config_lines = [\n        line\n        for line in config_lines\n        if all(exception not in line for exception in except_lines)\n    ]\n\n    # Ensure empty interfaces pattern\n    interface_lines = config_lines[1:-1]\n    for i in range(len(interface_lines)):\n        if i % 2 == 0:\n            line = interface_lines[i].split()\n            if (\n                line[0] != \"interface\"\n                or line[1] not in self.destination_device.PHYSICAL_INTERFACES_LIST\n            ):\n                return False\n        else:\n            if \"exit\" not in interface_lines[i]:\n                return False\n    return True\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.ping","title":"ping","text":"<pre><code>ping(\n    ip: str, nbr_packets: int = 1, ping_timeout: int = 1\n) -&gt; str\n</code></pre> <p>Sends a ping command to a specified IP address from the device. Supports both Linux and OneOS devices.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_connection\ndef ping(self, ip: str, nbr_packets: int = 1, ping_timeout: int = 1) -&gt; str:\n    \"\"\"\n    Sends a ping command to a specified IP address from the device.\n    Supports both Linux and OneOS devices.\n    \"\"\"\n    if self.destination_device.type == \"oneos\":\n        response = self.write_command(\n            f\"ping {ip} -n {nbr_packets} -w {ping_timeout}\"\n        )\n        logger.info(f\"Ping {nbr_packets * 5} packets at IP: {ip}\")\n        return response\n    elif self.destination_device.type == \"linux\":\n        response = self.write_command(\n            f\"ping {ip} -c {nbr_packets} -W {ping_timeout}\"\n        )\n        logger.info(f\"Ping {nbr_packets} packets at IP: {ip}\")\n        return response\n    else:\n        raise NotImplementedError(\n            f\"Ping not implemented for device type {self.destination_device.type}\"\n        )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.hping3","title":"hping3","text":"<pre><code>hping3(\n    destination_ip: str,\n    nbr_packets: Optional[int] = None,\n    interval: Optional[str] = None,\n    flood: bool = False,\n    port: Optional[int] = None,\n    type: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Execute hping3 command on the Linux device. For more information about hping3, see https://linux.die.net/man/8/hping3</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\")\ndef hping3(\n    self,\n    destination_ip: str,\n    nbr_packets: Optional[int] = None,\n    interval: Optional[str] = None,\n    flood: bool = False,\n    port: Optional[int] = None,\n    type: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Execute hping3 command on the Linux device.\n    For more information about hping3, see https://linux.die.net/man/8/hping3\n    \"\"\"\n    valid_types = [\"tcp\", \"udp\", \"icmp\", \"rawip\", \"syn\", \"ack\", \"fin\", \"rst\"]\n    full_command = \"hping3 \"\n    if nbr_packets is not None:\n        full_command += f\"-c {nbr_packets} \"\n    if interval is not None:\n        full_command += f\"-i {interval} \"\n    if flood:\n        full_command += \"--flood \"\n    if port is not None:\n        full_command += f\"-p {port} \"\n    if type is not None and type.lower() in valid_types:\n        full_command += f\"--{type} \"\n    self.write_command(full_command + destination_ip)\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.SSHConnection.reconfigure","title":"reconfigure","text":"<pre><code>reconfigure(commands_list: List[str]) -&gt; None\n</code></pre> <p>Reconfigures a OneOS device with a list of commands. The list of commands is expected to include the exact commands     to be sent to the device, with their \"exit\" commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands_list</code> <code>List[str]</code> <p>The list of commands to send to the device, excluding the \"config terminal\" and \"end\" commands.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a OneOS device.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef reconfigure(self, commands_list: List[str]) -&gt; None:\n    \"\"\"\n    Reconfigures a OneOS device with a list of commands.\n    The list of commands is expected to include the exact commands\n        to be sent to the device, with their \"exit\" commands.\n\n    Args:\n        commands_list (List[str]): The list of commands to send to the device, excluding the \"config terminal\" and \"end\" commands.\n\n    Raises:\n        ValueError: If the device is not a OneOS device.\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(\"Reconfiguring device ...\")\n    self.write_command(\"term len 0\")\n    self.write_command(\"config terminal\")\n    for command in commands_list:\n        self.write_command(command)\n    self.write_command(\"end\")\n    self.flush()\n    logger.debug(f\"reconfig commands: {' | '.join(commands_list)}\")\n    logger.info(\"Device reconfigured\")\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection","title":"TelnetConnection","text":"<p>               Bases: <code>Connection</code></p> <p>Represents a Telnet connection, always originating from the Host device to another device. It uses the telnetlib library to establish and manage the connection.</p> <p>.. deprecated:: 0.2.0     TelnetConnection is deprecated due to security concerns. Telnet transmits data in plain text.     Use SSHConnection instead for secure communication.</p> <p>.. warning::     This class will be removed in a future version. Please migrate to SSHConnection.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>class TelnetConnection(Connection):\n    \"\"\"\n    Represents a Telnet connection, always originating from the Host device to another device.\n    It uses the telnetlib library to establish and manage the connection.\n\n    .. deprecated:: 0.2.0\n        TelnetConnection is deprecated due to security concerns. Telnet transmits data in plain text.\n        Use SSHConnection instead for secure communication.\n\n    .. warning::\n        This class will be removed in a future version. Please migrate to SSHConnection.\n    \"\"\"\n\n    def __init__(self, timeout: int = 10):\n        super().__init__(timeout)\n\n        # Issue deprecation warning\n        warnings.warn(\n            \"TelnetConnection is deprecated and will be removed in a future version. \"\n            \"Use SSHConnection instead for secure communication.\",\n            DeprecationWarning,\n            stacklevel=2\n        )\n\n        self.resulting_telnet_connection = telnetlib.Telnet()  # Not connected\n\n    @Connection.check_occupied\n    def connect(self, destination_device: \"Device\", destination_ip: str) -&gt; Connection:\n        \"\"\"\n        First connection from Host Device to any other Device.\n        It uses an instantiated telnetlib.Telnet object, which is not connected yet.\n        Returns the resulting Connection object, which carries the now connected telnetlib.Telnet object.\n\n        Args:\n            destination_device (Device): The device object representing the destination device.\n                                         This object should contain the necessary credentials.\n            destination_ip (str): The IP address of the destination device.\n\n        Returns:\n            Connection: The resulting Connection object, which carries the now connected telnetlib.Telnet object.\n\n        Raises:\n            ConnectionAbortedError: If the connection could not be established.\n        \"\"\"\n        # Important to have a default, because if device is being reused (connect, set sudo, disconnect and then connect again),\n        # it will connect as a user but the prompt_symbol will be #, which is not the default for a user\n        self.prompt_symbol = destination_device.DEFAULT_PROMPT_SYMBOL\n        self.destination_device = destination_device\n        self.destination_ip = destination_ip\n\n        self.resulting_telnet_connection.open(\n            host=self.destination_ip, timeout=self.timeout\n        )\n        possible_login_prompts = [b\"Username:\", b\"login:\"]\n        self._write_credentials(possible_login_prompts, destination_device.username)\n        possible_password_prompts = [b\"Password:\"]\n        self._write_credentials(possible_password_prompts, destination_device.password)\n        encoded_prompt = self.prompt_symbol.encode(\"ascii\")\n        self.resulting_telnet_connection.read_until(encoded_prompt, self.timeout)\n\n        if not self.is_connected:\n            raise ConnectionAbortedError(\"Connection aborted: Could not connect\")\n        logger.info(\n            f\"Connected to {self.destination_device.hostname} at {self.destination_ip}\"\n        )\n        return self\n\n    def _write_credentials(\n        self, list_str_to_expect: List[str], str_to_write: str\n    ) -&gt; None:\n        if self.resulting_telnet_connection is not None:\n            n, match, previous_text = self.resulting_telnet_connection.expect(\n                list_str_to_expect, self.timeout\n            )\n            if n != -1:\n                self.resulting_telnet_connection.write(\n                    str_to_write.encode(\"ascii\") + b\"\\r\"\n                )\n            else:\n                logging.error(\n                    f\"EOFError: No match found. Match: {match}, Previous text: {previous_text}\"\n                )\n                raise EOFError\n        else:\n            logging.error(\n                \"No connection object from telnetlib found. It has been closed or was never created.\"\n            )\n\n    @Connection.check_occupied\n    def disconnect(self) -&gt; None:\n        self.resulting_telnet_connection.close()\n        if self.is_connected:\n            raise ConnectionError(\"Connection could not be closed\")\n        logger.info(\n            f\"Disconnected from {self.destination_device.hostname} at {self.destination_ip}\"\n        )\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Checks if the telnet connection is active, by attempting to access the socket.\n        \"\"\"\n        if not self.resulting_telnet_connection:\n            return False\n        try:\n            # If the Telnet connection is not active, this will raise an exception\n            _ = self.resulting_telnet_connection.get_socket().getsockopt(\n                socket.SOL_SOCKET, socket.SO_TYPE\n            )\n            return True\n        except Exception:\n            return False\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection-attributes","title":"Attributes","text":""},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Checks if the telnet connection is active, by attempting to access the socket.</p>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root: bool\n</code></pre> <p>Checks if the current user is root on a Linux device by writing the 'whoami' command and checking the response.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current user is root, False otherwise.</p>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection-functions","title":"Functions","text":""},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.connect","title":"connect","text":"<pre><code>connect(\n    destination_device: Device, destination_ip: str\n) -&gt; Connection\n</code></pre> <p>First connection from Host Device to any other Device. It uses an instantiated telnetlib.Telnet object, which is not connected yet. Returns the resulting Connection object, which carries the now connected telnetlib.Telnet object.</p> <p>Parameters:</p> Name Type Description Default <code>destination_device</code> <code>Device</code> <p>The device object representing the destination device.                          This object should contain the necessary credentials.</p> required <code>destination_ip</code> <code>str</code> <p>The IP address of the destination device.</p> required <p>Returns:</p> Name Type Description <code>Connection</code> <code>Connection</code> <p>The resulting Connection object, which carries the now connected telnetlib.Telnet object.</p> <p>Raises:</p> Type Description <code>ConnectionAbortedError</code> <p>If the connection could not be established.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@Connection.check_occupied\ndef connect(self, destination_device: \"Device\", destination_ip: str) -&gt; Connection:\n    \"\"\"\n    First connection from Host Device to any other Device.\n    It uses an instantiated telnetlib.Telnet object, which is not connected yet.\n    Returns the resulting Connection object, which carries the now connected telnetlib.Telnet object.\n\n    Args:\n        destination_device (Device): The device object representing the destination device.\n                                     This object should contain the necessary credentials.\n        destination_ip (str): The IP address of the destination device.\n\n    Returns:\n        Connection: The resulting Connection object, which carries the now connected telnetlib.Telnet object.\n\n    Raises:\n        ConnectionAbortedError: If the connection could not be established.\n    \"\"\"\n    # Important to have a default, because if device is being reused (connect, set sudo, disconnect and then connect again),\n    # it will connect as a user but the prompt_symbol will be #, which is not the default for a user\n    self.prompt_symbol = destination_device.DEFAULT_PROMPT_SYMBOL\n    self.destination_device = destination_device\n    self.destination_ip = destination_ip\n\n    self.resulting_telnet_connection.open(\n        host=self.destination_ip, timeout=self.timeout\n    )\n    possible_login_prompts = [b\"Username:\", b\"login:\"]\n    self._write_credentials(possible_login_prompts, destination_device.username)\n    possible_password_prompts = [b\"Password:\"]\n    self._write_credentials(possible_password_prompts, destination_device.password)\n    encoded_prompt = self.prompt_symbol.encode(\"ascii\")\n    self.resulting_telnet_connection.read_until(encoded_prompt, self.timeout)\n\n    if not self.is_connected:\n        raise ConnectionAbortedError(\"Connection aborted: Could not connect\")\n    logger.info(\n        f\"Connected to {self.destination_device.hostname} at {self.destination_ip}\"\n    )\n    return self\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.check_occupied","title":"check_occupied","text":"<pre><code>check_occupied(func)\n</code></pre> <p>Decorator to check if the connection is already in use and hence not available.</p> <p>This decorator is used to wrap methods that should not be executed if the connection is already in use.</p> <p>Raises:</p> Type Description <code>ConnectionRefusedError</code> <p>If the connection is already in use.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_occupied(func):\n    \"\"\"\n    Decorator to check if the connection is already in use and hence not available.\n\n    This decorator is used to wrap methods that should not be executed if the connection is already in use.\n\n    Raises:\n        ConnectionRefusedError: If the connection is already in use.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        if self._is_occupied:\n            raise ConnectionRefusedError(\n                \"This connection is already in use. Please close the connections that use it first.\"\n            )\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.check_device_type","title":"check_device_type","text":"<pre><code>check_device_type(required_type, is_root: bool = False)\n</code></pre> <p>Decorator to check the device type and connection privileges before executing a function.</p> <p>Parameters:</p> Name Type Description Default <code>required_type</code> <code>str</code> <p>The required device type for the function to be executed.</p> required <code>is_root</code> <code>bool</code> <p>If True, the function requires root privileges to be executed. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not of the required type.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If root privileges are required but the user does not have them.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_device_type(required_type, is_root: bool = False):\n    \"\"\"\n    Decorator to check the device type and connection privileges before executing a function.\n\n    Args:\n        required_type (str): The required device type for the function to be executed.\n        is_root (bool, optional): If True, the function requires root privileges to be executed. Defaults to False.\n\n    Raises:\n        ValueError: If the device is not of the required type.\n        ConnectionError: If the device is not connected.\n        PermissionError: If root privileges are required but the user does not have them.\n    \"\"\"\n\n    def decorator(func):\n        def wrapper(self, *args, **kwargs):\n            if self.destination_device.type != required_type:\n                raise ValueError(\n                    f'This method is available only for {required_type} devices, but the destination device is of type \"{self.destination_device.type}\".'\n                )\n            # Perform the connection check too, since it's a common requirement\n            if not self.is_connected:\n                raise ConnectionError(\"Device is not connected\")\n            if is_root and not self.is_root:\n                raise PermissionError(\n                    \"Root privileges required to perform this action\"\n                )\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.check_connection","title":"check_connection","text":"<pre><code>check_connection(func)\n</code></pre> <p>Decorator to check if the device is connected before executing a function.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_connection(func):\n    \"\"\"\n    Decorator to check if the device is connected before executing a function.\n\n    Raises:\n        ConnectionError: If the device is not connected.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        if not self.is_connected:\n            raise ConnectionError(\"Device is not connected\")\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.write_command","title":"write_command","text":"<pre><code>write_command(\n    command: str,\n    expected_prompt_pattern: Optional[List[str]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Optional[str]\n</code></pre> <p>Writes a command to the telnet connection and returns the response.</p> <p>This method sends a command to the device via the telnet connection, waits for a response, and then returns that response. The response is expected to end with a prompt symbol or match an expected pattern, which is specified by the <code>expected_prompt_pattern</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to be sent to the device.</p> required <code>expected_prompt_pattern</code> <code>Optional[List[str]]</code> <p>A list of regex patterns that the response is expected to match. If None, the method waits for the prompt symbol. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>The maximum time to wait for a response, in seconds. If None, the method uses the default timeout. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The response from the device, or None if there was no response.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the telnet connection is not established.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef write_command(\n    self,\n    command: str,\n    expected_prompt_pattern: Optional[List[str]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Optional[str]:\n    \"\"\"\n    Writes a command to the telnet connection and returns the response.\n\n    This method sends a command to the device via the telnet connection, waits for a response, and then returns that response.\n    The response is expected to end with a prompt symbol or match an expected pattern, which is specified by the `expected_prompt_pattern` parameter.\n\n    Args:\n        command (str): The command to be sent to the device.\n        expected_prompt_pattern (Optional[List[str]]): A list of regex patterns that the response is expected to match. If None, the method waits for the prompt symbol. Defaults to None.\n        timeout (Optional[int]): The maximum time to wait for a response, in seconds. If None, the method uses the default timeout. Defaults to None.\n\n    Returns:\n        Optional[str]: The response from the device, or None if there was no response.\n\n    Raises:\n        ConnectionError: If the telnet connection is not established.\n    \"\"\"\n    self.flush()  # Make sure nothing is in the buffer\n\n    if self.resulting_telnet_connection is not None:\n        # If the command is a string, encode it to bytes first\n        command = (\n            command.encode(\"ascii\") + b\"\\r\"\n            if hasattr(command, \"encode\")\n            else command\n        )\n        self.resulting_telnet_connection.write(command)\n        assert self.prompt_symbol is not None, \"Prompt symbol is not defined.\"\n\n        # \"expect\" can wait for multiple patterns\n        if expected_prompt_pattern:\n            response = self.resulting_telnet_connection.expect(\n                expected_prompt_pattern,\n                timeout or self.timeout,\n            )[2]  # The third element of the tuple is the response\n        # but \"read_until\", while only for one pattern (prompt_symbol), is more reliable\n        else:\n            response = self.resulting_telnet_connection.read_until(\n                self.prompt_symbol.encode(\"ascii\"), timeout or self.timeout\n            )\n        response = response.decode(\"ascii\") if response else None\n    else:\n        raise ConnectionError(\n            \"No connection object from Telnet found during write_command.\"\n        )\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.flush","title":"flush","text":"<pre><code>flush(time_interval: int = 0.1) -&gt; None\n</code></pre> <p>This method waits for a short period of time to allow any remaining data to arrive, then reads and discards all data that has arrived at the telnet connection.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef flush(self, time_interval: int = 0.1) -&gt; None:\n    \"\"\"\n    This method waits for a short period of time to allow any remaining data to arrive,\n    then reads and discards all data that has arrived at the telnet connection.\n    \"\"\"\n    try:\n        time.sleep(time_interval)\n        if self.resulting_telnet_connection is not None:\n            self.resulting_telnet_connection.read_very_eager()\n    except EOFError as eof:\n        logger.error(\n            f\"EOFError. Usually something is wrong while loading the connection. | {eof}\"\n        )\n        raise EOFError from eof\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.read_until","title":"read_until","text":"<pre><code>read_until(\n    prompt: bytes, timeout: Optional[int] = None\n) -&gt; Optional[str]\n</code></pre> <p>Reads data from the telnet connection until a specified prompt is encountered or until timeout.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>bytes</code> <p>The prompt to read until.</p> required <code>timeout</code> <code>Optional[int]</code> <p>The maximum time to wait for the prompt, in seconds. If None, the method uses the default timeout. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The data read from the connection, or None if no data was read.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef read_until(self, prompt: bytes, timeout: Optional[int] = None) -&gt; Optional[str]:\n    \"\"\"\n    Reads data from the telnet connection until a specified prompt is encountered or until timeout.\n\n    Args:\n        prompt (bytes): The prompt to read until.\n        timeout (Optional[int]): The maximum time to wait for the prompt, in seconds. If None, the method uses the default timeout. Defaults to None.\n\n    Returns:\n        Optional[str]: The data read from the connection, or None if no data was read.\n    \"\"\"\n    if timeout is not None:\n        self.timeout = timeout\n    if self.resulting_telnet_connection is not None:\n        response = self.resulting_telnet_connection.read_until(prompt, self.timeout)\n        response = response.decode(\"ascii\") if response else None\n    else:\n        raise NotImplementedError(\n            \"No connection object from Telnet found during read_until.\"\n        )\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.load_config","title":"load_config","text":"<pre><code>load_config(config_path: str) -&gt; None\n</code></pre> <p>Loads a configuration file to a OneOS device.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>The path to the configuration file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a OneOS device.</p> <code>OSError</code> <p>If the configuration file fails to open (might not exist).</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef load_config(self, config_path: str) -&gt; None:\n    \"\"\"\n    Loads a configuration file to a OneOS device.\n\n    Args:\n        config_path (str): The path to the configuration file.\n\n    Raises:\n        ValueError: If the device is not a OneOS device.\n        OSError: If the configuration file fails to open (might not exist).\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(f\"Loading config {config_path.split('/')[-1]} ...\")\n    self.write_command(\"term len 0\")\n    with open(config_path) as fp:\n        for line in fp:\n            if line.strip().startswith(\"!\"):\n                continue  # Skip comment lines\n            if \"hostname\" in line:\n                self.destination_device.hostname = line.split()[-1]\n            response = self.write_command(line)\n\n    # Check that prompt has exited config terminal fully. Search for \"localhost#\" (default) or \"&lt;configured_hostname&gt;#\"\n    self.prompt_symbol = f\"{self.destination_device.hostname}#\"\n    response = self.write_command(\"\\n\").strip()\n    if response != self.prompt_symbol:\n        logger.warning(\n            f\"Loading config might have failed, prompt is not as expected. Received {response} but expected {self.prompt_symbol} instead\"\n        )\n        logger.debug(\n            'Sometimes the developer has miscalculated the \"exit\" commands in the BSA'\n        )\n        self.write_command(\"end\")\n    logger.info(\n        f\"Loaded configuration to device {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.set_sudo","title":"set_sudo","text":"<pre><code>set_sudo(root_password: Optional[str] = None) -&gt; None\n</code></pre> <p>Sets sudo privileges for a Linux device. The prompt symbol is updated to '#' to reflect the change to the root user.</p> <p>Parameters:</p> Name Type Description Default <code>root_password</code> <code>Optional[str]</code> <p>The root password. If None, the method uses the password of the destination device. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a Linux device.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>AssertionError</code> <p>If the method fails to switch to the root user.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\")\ndef set_sudo(self, root_password: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Sets sudo privileges for a Linux device.\n    The prompt symbol is updated to '#' to reflect the change to the root user.\n\n    Args:\n        root_password (Optional[str]): The root password. If None, the method uses the password of the destination device. Defaults to None.\n\n    Raises:\n        ValueError: If the device is not a Linux device.\n        ConnectionError: If the device is not connected.\n        AssertionError: If the method fails to switch to the root user.\n    \"\"\"\n    if root_password is None:\n        root_password = self.destination_device.password\n    self.write_command(\"sudo su\", expected_prompt_pattern=[b\"password for user:\"])\n    self.write_command(root_password, expected_prompt_pattern=[b\"#\"])\n    self.prompt_symbol = \"#\"  # In Linux, changes from '$' to '#' if root\n    assert self.is_root, \"Failed to identify root user\"\n    logger.info(\n        f\"Sudo privileges set for linux device: {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.set_interface_ip","title":"set_interface_ip","text":"<pre><code>set_interface_ip(\n    interface_name: str,\n    ip_addr: str,\n    netmask: str = \"24\",\n    interface_state: str = \"up\",\n) -&gt; None\n</code></pre> <p>Sets the IP address, netmask, and state of a specified interface on a Linux device.</p> <p>Parameters:</p> Name Type Description Default <code>interface_name</code> <code>str</code> <p>The name of the interface.</p> required <code>ip_addr</code> <code>str</code> <p>The IP address to set.</p> required <code>netmask</code> <code>str</code> <p>The netmask to set. Defaults to \"24\".</p> <code>'24'</code> <code>interface_state</code> <code>str</code> <p>The state of the interface. Must be 'up' or 'down'. Defaults to \"up\".</p> <code>'up'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the IP address is invalid, if the interface does not exist or if the device type is not Linux.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If the user does not have root privileges.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\", is_root=True)\ndef set_interface_ip(\n    self,\n    interface_name: str,\n    ip_addr: str,\n    netmask: str = \"24\",\n    interface_state: str = \"up\",\n) -&gt; None:\n    \"\"\"\n    Sets the IP address, netmask, and state of a specified interface on a Linux device.\n\n    Args:\n        interface_name (str): The name of the interface.\n        ip_addr (str): The IP address to set.\n        netmask (str, optional): The netmask to set. Defaults to \"24\".\n        interface_state (str, optional): The state of the interface. Must be 'up' or 'down'. Defaults to \"up\".\n\n    Raises:\n        ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n        ConnectionError: If the device is not connected.\n        PermissionError: If the user does not have root privileges.\n    \"\"\"\n    if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n        raise ValueError(\"Invalid IP address.\")\n    if interface_state not in [\"up\", \"down\"]:\n        logger.error(\n            f\"Invalid state: {interface_state}. Must be 'up' or 'down'. Passing 'up' by default.\"\n        )\n        interface_state = \"up\"\n    if self._get_interface(interface_name) is None:\n        raise ValueError(f\"Interface {interface_name} not found\")\n    self.write_command(f\"ip addr add {ip_addr}/{netmask} dev {interface_name}\")\n    self.write_command(f\"ip link set {interface_name} {interface_state}\")\n    logger.info(\n        f\"Interface {interface_name} set to IP {ip_addr} with netmask {netmask} and state {interface_state}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.delete_interface_ip","title":"delete_interface_ip","text":"<pre><code>delete_interface_ip(\n    interface_name: str, ip_addr: str, netmask: str = \"24\"\n) -&gt; None\n</code></pre> <p>Deletes the IP address from a specified interface on a Linux device.</p> <p>Parameters:</p> Name Type Description Default <code>interface_name</code> <code>str</code> <p>The name of the interface.</p> required <code>ip_addr</code> <code>str</code> <p>The IP address to delete.</p> required <code>netmask</code> <code>str</code> <p>The netmask of the IP address. Defaults to \"24\".</p> <code>'24'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the IP address is invalid, if the interface does not exist or if the device type is not Linux.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If the user does not have root privileges.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\", is_root=True)\ndef delete_interface_ip(\n    self, interface_name: str, ip_addr: str, netmask: str = \"24\"\n) -&gt; None:\n    \"\"\"\n    Deletes the IP address from a specified interface on a Linux device.\n\n    Args:\n        interface_name (str): The name of the interface.\n        ip_addr (str): The IP address to delete.\n        netmask (str, optional): The netmask of the IP address. Defaults to \"24\".\n\n    Raises:\n        ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n        ConnectionError: If the device is not connected.\n        PermissionError: If the user does not have root privileges.\n    \"\"\"\n    if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n        raise ValueError(\"Invalid IP address.\")\n    if self._get_interface(interface_name) is None:\n        raise ValueError(f\"Interface {interface_name} not found\")\n    self.write_command(f\"ip addr del {ip_addr}/{netmask} dev {interface_name}\")\n    logger.info(\n        f\"IP {ip_addr} with netmask {netmask} deleted from interface {interface_name}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.unload_interface","title":"unload_interface","text":"<pre><code>unload_interface(\n    interface_line: str, wrap_command: bool = True\n) -&gt; Optional[str]\n</code></pre> <p>Resets the configuration of a specified interface to its default settings. OneOS6 WARNING: \"By configuring the interface back to default, it is possible that some services will not work any more\"</p> <p>Parameters:</p> Name Type Description Default <code>interface_line</code> <code>str</code> <p>The line of the full interface name to reset (i.e. interface gigabitethernet 0/0).</p> required <code>wrap_command</code> <code>bool</code> <p>If True, the method enters and exits the \"configure terminal\" command.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The response from the device after sending the 'default' command, or None if there was no response.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef unload_interface(\n    self, interface_line: str, wrap_command: bool = True\n) -&gt; Optional[str]:\n    \"\"\"\n    Resets the configuration of a specified interface to its default settings.\n    OneOS6 WARNING: \"By configuring the interface back to default, it is possible that some services will not work any more\"\n\n    Args:\n        interface_line (str): The line of the full interface name to reset (i.e. interface gigabitethernet 0/0).\n        wrap_command (bool, optional): If True, the method enters and exits the \"configure terminal\" command.\n\n    Returns:\n        Optional[str]: The response from the device after sending the 'default' command, or None if there was no response.\n    \"\"\"\n    self.write_command(\"config terminal\") if wrap_command else None\n    response = self.write_command(f\"default {interface_line}\")\n    self.write_command(\"end\") if wrap_command else None\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.unload_config","title":"unload_config","text":"<pre><code>unload_config(\n    unload_specific_commands: Optional[List[str]] = None,\n    check_is_empty: bool = False,\n) -&gt; None\n</code></pre> <p>Unloads the configuration of the device using a bottom-up approach. The configurations on the bottom of the config inherit properties from the configurations above them.</p> <p>Sometimes, even by that approach, some commands cannot be unloaded. In that case, the user must manually unload them,     by providing the no-commands in the unload_specific_commands parameter.</p> <p>The config is retrieved by the very slow \"show running-config\" command. If check_is_empty is True,     \"show running-config\" is called again (another couple of seconds wait time), that's why default is to not check.</p> <p>Parameters:</p> Name Type Description Default <code>unload_specific_commands</code> <code>Optional[List[str]]</code> <p>A list of specific commands to unload. Defaults to None.</p> <code>None</code> <code>check_is_empty</code> <code>bool</code> <p>If True, the method checks if the configuration is empty after unloading. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration is not fully unloaded and check_is_empty is True, or if device type is not oneos.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef unload_config(\n    self,\n    unload_specific_commands: Optional[List[str]] = None,\n    check_is_empty: bool = False,\n) -&gt; None:\n    \"\"\"\n    Unloads the configuration of the device using a bottom-up approach.\n    The configurations on the bottom of the config inherit properties from the configurations above them.\n\n    Sometimes, even by that approach, some commands cannot be unloaded. In that case, the user must manually unload them,\n        by providing the no-commands in the unload_specific_commands parameter.\n\n    The config is retrieved by the very slow \"show running-config\" command. If check_is_empty is True,\n        \"show running-config\" is called again (another couple of seconds wait time), that's why default is to not check.\n\n    Args:\n        unload_specific_commands (Optional[List[str]]): A list of specific commands to unload. Defaults to None.\n        check_is_empty (bool, optional): If True, the method checks if the configuration is empty after unloading. Defaults to False.\n\n    Raises:\n        ValueError: If the configuration is not fully unloaded and check_is_empty is True, or if device type is not oneos.\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(\n        f\"Unloading config for device {self.destination_device.hostname} ...\"\n    )\n    self.write_command(\"term len 0\")\n    self.flush()\n\n    config_lines = self.write_command(\"show running-config\").split(\"\\n\")\n    config_lines_reverse = config_lines[::-1]  # Traverse from bottom to top\n\n    self.prompt_symbol = \"#\"\n    self.write_command(\"config terminal\")\n\n    # Unload ip routes\n    for line in config_lines_reverse:\n        if re.search(r\"^(ip(v6|) (route|host)|aaa authentication login)\", line):\n            self.write_command(f\"no {line}\")\n        elif re.search(r\"^radius-server\", line):\n            self.write_command(f\"no radius-server {line.split(' ')[1]}\")\n        if \"exit\" in line:\n            break\n\n    # Unload interfaces\n    for line in config_lines_reverse:\n        if line.startswith(\"interface\"):\n            # If any of the interfaces listed in permanent_interfaces is a substring of the line\n            if any(\n                interface in line\n                for interface in self.destination_device.PHYSICAL_INTERFACES_LIST\n            ):\n                self.unload_interface(line, wrap_command=False)\n            else:\n                self.write_command(f\"no {line}\")\n\n    # Get all the lines until the first interface\n    interface_index = next(\n        (i for i, line in enumerate(config_lines) if line.startswith(\"interface\")),\n        None,\n    )\n    config_lines_until_interfaces = config_lines[:interface_index]\n    # Get all the lines that are not preceded with space -&gt; assumes that they are unloaded as part of the main line unload\n    main_lines = [\n        line\n        for line in config_lines_until_interfaces\n        if (not line.startswith(\" \") and \"exit\" not in line)\n    ]\n    for line in main_lines[:1:-1]:  # Traverse from bottom to top again\n        if \"license activate\" in line:\n            continue\n        # NOTE: Ignore cases that the \"no\" prefix will not work, expect the user to manually unload these in the loop below\n        self.write_command(f\"no {line}\")\n\n    # Finally, if user knows that there are configuration leftovers, unload it manually\n    if unload_specific_commands is not None:\n        for command in unload_specific_commands:\n            self.write_command(command)\n\n    self.write_command(\"hostname localhost\")\n    self.write_command(\"end\")\n    self.flush()\n\n    # NOTE: By default, keep check to False because \"show running-config\" takes ~4s to return response\n    if check_is_empty and not self.is_config_empty(\n        self.write_command(\"show running-config\")\n    ):\n        logger.error(\n            f\"Config not fully unloaded for device {self.destination_device.hostname}\"\n        )\n        return\n    logger.info(\n        f\"Config unloading effort finished for device {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.is_config_empty","title":"is_config_empty","text":"<pre><code>is_config_empty(\n    configuration: str,\n    except_lines: Optional[List[str]] = None,\n) -&gt; bool\n</code></pre> <p>Checks if the configuration of the device is fully empty and return boolean.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def is_config_empty(\n    self, configuration: str, except_lines: Optional[List[str]] = None\n) -&gt; bool:\n    \"\"\"\n    Checks if the configuration of the device is fully empty and return boolean.\n    \"\"\"\n    config_lines = configuration.split(\"\\n\")\n    if (\n        \"show running-config\" not in config_lines[0]\n        or \"localhost#\" not in config_lines[-1]\n    ):\n        logger.debug(f\"Returned config is not okay: {config_lines}\")\n        return False\n\n    # Remove lines that should not be checked (lines in `except_lines` list)\n    config_lines = [\n        line\n        for line in config_lines\n        if all(exception not in line for exception in except_lines)\n    ]\n\n    # Ensure empty interfaces pattern\n    interface_lines = config_lines[1:-1]\n    for i in range(len(interface_lines)):\n        if i % 2 == 0:\n            line = interface_lines[i].split()\n            if (\n                line[0] != \"interface\"\n                or line[1] not in self.destination_device.PHYSICAL_INTERFACES_LIST\n            ):\n                return False\n        else:\n            if \"exit\" not in interface_lines[i]:\n                return False\n    return True\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.ping","title":"ping","text":"<pre><code>ping(\n    ip: str, nbr_packets: int = 1, ping_timeout: int = 1\n) -&gt; str\n</code></pre> <p>Sends a ping command to a specified IP address from the device. Supports both Linux and OneOS devices.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_connection\ndef ping(self, ip: str, nbr_packets: int = 1, ping_timeout: int = 1) -&gt; str:\n    \"\"\"\n    Sends a ping command to a specified IP address from the device.\n    Supports both Linux and OneOS devices.\n    \"\"\"\n    if self.destination_device.type == \"oneos\":\n        response = self.write_command(\n            f\"ping {ip} -n {nbr_packets} -w {ping_timeout}\"\n        )\n        logger.info(f\"Ping {nbr_packets * 5} packets at IP: {ip}\")\n        return response\n    elif self.destination_device.type == \"linux\":\n        response = self.write_command(\n            f\"ping {ip} -c {nbr_packets} -W {ping_timeout}\"\n        )\n        logger.info(f\"Ping {nbr_packets} packets at IP: {ip}\")\n        return response\n    else:\n        raise NotImplementedError(\n            f\"Ping not implemented for device type {self.destination_device.type}\"\n        )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.hping3","title":"hping3","text":"<pre><code>hping3(\n    destination_ip: str,\n    nbr_packets: Optional[int] = None,\n    interval: Optional[str] = None,\n    flood: bool = False,\n    port: Optional[int] = None,\n    type: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Execute hping3 command on the Linux device. For more information about hping3, see https://linux.die.net/man/8/hping3</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\")\ndef hping3(\n    self,\n    destination_ip: str,\n    nbr_packets: Optional[int] = None,\n    interval: Optional[str] = None,\n    flood: bool = False,\n    port: Optional[int] = None,\n    type: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Execute hping3 command on the Linux device.\n    For more information about hping3, see https://linux.die.net/man/8/hping3\n    \"\"\"\n    valid_types = [\"tcp\", \"udp\", \"icmp\", \"rawip\", \"syn\", \"ack\", \"fin\", \"rst\"]\n    full_command = \"hping3 \"\n    if nbr_packets is not None:\n        full_command += f\"-c {nbr_packets} \"\n    if interval is not None:\n        full_command += f\"-i {interval} \"\n    if flood:\n        full_command += \"--flood \"\n    if port is not None:\n        full_command += f\"-p {port} \"\n    if type is not None and type.lower() in valid_types:\n        full_command += f\"--{type} \"\n    self.write_command(full_command + destination_ip)\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetConnection.reconfigure","title":"reconfigure","text":"<pre><code>reconfigure(commands_list: List[str]) -&gt; None\n</code></pre> <p>Reconfigures a OneOS device with a list of commands. The list of commands is expected to include the exact commands     to be sent to the device, with their \"exit\" commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands_list</code> <code>List[str]</code> <p>The list of commands to send to the device, excluding the \"config terminal\" and \"end\" commands.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a OneOS device.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef reconfigure(self, commands_list: List[str]) -&gt; None:\n    \"\"\"\n    Reconfigures a OneOS device with a list of commands.\n    The list of commands is expected to include the exact commands\n        to be sent to the device, with their \"exit\" commands.\n\n    Args:\n        commands_list (List[str]): The list of commands to send to the device, excluding the \"config terminal\" and \"end\" commands.\n\n    Raises:\n        ValueError: If the device is not a OneOS device.\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(\"Reconfiguring device ...\")\n    self.write_command(\"term len 0\")\n    self.write_command(\"config terminal\")\n    for command in commands_list:\n        self.write_command(command)\n    self.write_command(\"end\")\n    self.flush()\n    logger.debug(f\"reconfig commands: {' | '.join(commands_list)}\")\n    logger.info(\"Device reconfigured\")\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection","title":"TelnetCLIConnection","text":"<p>               Bases: <code>Connection</code></p> <p>Represents a CLI (Command Line Interface) connection over Telnet, used as a hop from a connected device to another. It is the equivalent of an open terminal, and then the developer executing \"telnet \". For the initialization of this connection type, a already connected TelnetConnection object is required. <p>When instantiated properly, the base connection is set to \"occupied\" and is not available for use by other connections. If this TelnetCLIConnection object is used as a base connection for another TelnetCLIConnection object, then it is also set as \"occupied\". The base connections are freed when the exit() or the disconnect() methods of this object are called.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>class TelnetCLIConnection(Connection):\n    \"\"\"\n    Represents a CLI (Command Line Interface) connection over Telnet, used as a hop from a connected device to another.\n    It is the equivalent of an open terminal, and then the developer executing \"telnet &lt;ip&gt;\".\n    For the initialization of this connection type, a already connected TelnetConnection object is required.\n\n    When instantiated properly, the base connection is set to \"occupied\" and is not available for use by other connections.\n    If this TelnetCLIConnection object is used as a base connection for another TelnetCLIConnection object, then it is also set as \"occupied\".\n    The base connections are freed when the exit() or the disconnect() methods of this object are called.\n    \"\"\"\n\n    def __init__(self, source_connection: \"TelnetConnection\", timeout: int = 10):\n        super().__init__(timeout)\n        self.source_connection = source_connection\n        if self.source_connection.resulting_telnet_connection is None:\n            raise ConnectionError(\n                \"No connection object found during TelnetCLIConnection instantiation.\"\n            )\n        if self.source_connection._is_occupied:\n            raise ConnectionRefusedError(\n                \"The source connection is already in use. Please close the connections that use it first.\"\n            )\n        self.resulting_telnet_connection = (\n            self.source_connection.resulting_telnet_connection\n        )\n        self._is_disconnected = True  # For internal use, to monitor when explicitly disconnecting. is_connected checks for the socket only\n\n    @Connection.check_occupied\n    def connect(self, destination_device: \"Device\", destination_ip: str) -&gt; Connection:\n        \"\"\"\n        This method uses the source device's connection to establish a new Telnet connection to the next destination device.\n\n        Args:\n            destination_device (Device): The device object representing the destination device.\n                                         This object should contain the necessary credentials.\n            destination_ip (str): The IP address of the destination device.\n\n        Returns:\n            Connection: The resulting Connection object, which carries the now connected telnetlib.Telnet object.\n\n        Raises:\n            ConnectionRefusedError: If the connection is refused by the destination device.\n            ConnectionAbortedError: If the necessary prompts are not retrieved during the login process.\n            ConnectionError: If the connection could not be established or if there is an error during the connection process.\n        \"\"\"\n        # Will need the info from the source_connection's destination_device until fully connecting (i.e. prompt_symbol)\n        self.destination_device = (\n            self.source_connection.destination_device\n        )  # pass by reference\n        self.prompt_symbol = self.source_connection.prompt_symbol\n        username = destination_device.username\n        password = destination_device.password\n\n        response = self.write_command(\n            f\"telnet {destination_ip}\",\n            expected_prompt_pattern=[b\"Username:\", b\"login:\"],\n            timeout=self.timeout,\n        )\n        if \"Connection closed by foreign host\" in response:\n            raise ConnectionRefusedError(\n                \"Connection refused: could not connect to next hop.\"\n            )\n        if \"Username:\" not in response and \"login:\" not in response:\n            raise ConnectionAbortedError(\n                \"Connection aborted: Username or Login prompts not retrieved.\"\n            )\n        response = self.write_command(\n            username + \"\\n\",\n            expected_prompt_pattern=[b\"Password:\"],\n            timeout=self.timeout,\n        )\n        if \"Password:\" not in response:\n            raise ConnectionAbortedError(\n                \"Connection aborted: Password prompt not retrieved.\"\n            )\n        response = self.write_command(\n            password + \"\\n\",\n            expected_prompt_pattern=[b\"connected\", b\"Welcome\"],\n            timeout=self.timeout,\n        )\n        if \"connected\" not in response and \"Welcome\" not in response:\n            raise ConnectionError(\"Connection error: Could not connect to next hop.\")\n\n        # Finally, update with the most recent connection info\n        self.source_connection._is_occupied = True\n        self.destination_device = destination_device\n        self.prompt_symbol = self.destination_device.DEFAULT_PROMPT_SYMBOL\n        self.destination_ip = destination_ip\n        self._is_disconnected = False\n\n        if not self.is_connected:\n            raise ConnectionError(\"Connection could not be established\")\n        logger.info(\n            \"Connected \"\n            + f\"from {self.source_connection.destination_device.hostname} \"\n            + f\"to {self.destination_device.hostname} at {self.destination_ip}\"\n        )\n        return self\n\n    @property\n    def is_occupied(self) -&gt; bool:\n        \"\"\"\n        Checks if the connection is currently in use.\n        \"\"\"\n        if not self.is_connected:\n            self.source_connection._is_occupied = False\n            self._is_occupied = False\n        return self._is_occupied\n\n    @Connection.check_occupied\n    def disconnect(self) -&gt; None:\n        self.exit()\n\n    @Connection.check_occupied\n    def exit(self) -&gt; Union[\"TelnetConnection\", \"TelnetCLIConnection\"]:\n        \"\"\"\n        Exits the current connection, but it doesn't close the socket, just returns to the previous hop.\n\n        Returns:\n            Union[TelnetConnection, TelnetCLIConnection]: The previous hop's connection object.\n        \"\"\"\n        self.source_connection._is_occupied = False\n        # Write \"exit\" to jump back to previous hop\n        self.write_command(\n            command=\"exit\",\n            expected_prompt_pattern=[b\"closed\", b\"Connection closed by foreign host.\"],\n            timeout=self.timeout,\n        )\n        # Obligatory to return connection object because it might be of a different type\n        self._is_disconnected = True\n        logger.info(\n            f\"Jumped back to previous hop at device {self.source_connection.destination_device.hostname}\"\n        )\n        return self.source_connection\n\n    @property\n    def is_connected(self) -&gt; bool:\n        return self.source_connection.is_connected and not self._is_disconnected\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection-attributes","title":"Attributes","text":""},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.is_occupied","title":"is_occupied  <code>property</code>","text":"<pre><code>is_occupied: bool\n</code></pre> <p>Checks if the connection is currently in use.</p>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root: bool\n</code></pre> <p>Checks if the current user is root on a Linux device by writing the 'whoami' command and checking the response.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the current user is root, False otherwise.</p>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection-functions","title":"Functions","text":""},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.connect","title":"connect","text":"<pre><code>connect(\n    destination_device: Device, destination_ip: str\n) -&gt; Connection\n</code></pre> <p>This method uses the source device's connection to establish a new Telnet connection to the next destination device.</p> <p>Parameters:</p> Name Type Description Default <code>destination_device</code> <code>Device</code> <p>The device object representing the destination device.                          This object should contain the necessary credentials.</p> required <code>destination_ip</code> <code>str</code> <p>The IP address of the destination device.</p> required <p>Returns:</p> Name Type Description <code>Connection</code> <code>Connection</code> <p>The resulting Connection object, which carries the now connected telnetlib.Telnet object.</p> <p>Raises:</p> Type Description <code>ConnectionRefusedError</code> <p>If the connection is refused by the destination device.</p> <code>ConnectionAbortedError</code> <p>If the necessary prompts are not retrieved during the login process.</p> <code>ConnectionError</code> <p>If the connection could not be established or if there is an error during the connection process.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@Connection.check_occupied\ndef connect(self, destination_device: \"Device\", destination_ip: str) -&gt; Connection:\n    \"\"\"\n    This method uses the source device's connection to establish a new Telnet connection to the next destination device.\n\n    Args:\n        destination_device (Device): The device object representing the destination device.\n                                     This object should contain the necessary credentials.\n        destination_ip (str): The IP address of the destination device.\n\n    Returns:\n        Connection: The resulting Connection object, which carries the now connected telnetlib.Telnet object.\n\n    Raises:\n        ConnectionRefusedError: If the connection is refused by the destination device.\n        ConnectionAbortedError: If the necessary prompts are not retrieved during the login process.\n        ConnectionError: If the connection could not be established or if there is an error during the connection process.\n    \"\"\"\n    # Will need the info from the source_connection's destination_device until fully connecting (i.e. prompt_symbol)\n    self.destination_device = (\n        self.source_connection.destination_device\n    )  # pass by reference\n    self.prompt_symbol = self.source_connection.prompt_symbol\n    username = destination_device.username\n    password = destination_device.password\n\n    response = self.write_command(\n        f\"telnet {destination_ip}\",\n        expected_prompt_pattern=[b\"Username:\", b\"login:\"],\n        timeout=self.timeout,\n    )\n    if \"Connection closed by foreign host\" in response:\n        raise ConnectionRefusedError(\n            \"Connection refused: could not connect to next hop.\"\n        )\n    if \"Username:\" not in response and \"login:\" not in response:\n        raise ConnectionAbortedError(\n            \"Connection aborted: Username or Login prompts not retrieved.\"\n        )\n    response = self.write_command(\n        username + \"\\n\",\n        expected_prompt_pattern=[b\"Password:\"],\n        timeout=self.timeout,\n    )\n    if \"Password:\" not in response:\n        raise ConnectionAbortedError(\n            \"Connection aborted: Password prompt not retrieved.\"\n        )\n    response = self.write_command(\n        password + \"\\n\",\n        expected_prompt_pattern=[b\"connected\", b\"Welcome\"],\n        timeout=self.timeout,\n    )\n    if \"connected\" not in response and \"Welcome\" not in response:\n        raise ConnectionError(\"Connection error: Could not connect to next hop.\")\n\n    # Finally, update with the most recent connection info\n    self.source_connection._is_occupied = True\n    self.destination_device = destination_device\n    self.prompt_symbol = self.destination_device.DEFAULT_PROMPT_SYMBOL\n    self.destination_ip = destination_ip\n    self._is_disconnected = False\n\n    if not self.is_connected:\n        raise ConnectionError(\"Connection could not be established\")\n    logger.info(\n        \"Connected \"\n        + f\"from {self.source_connection.destination_device.hostname} \"\n        + f\"to {self.destination_device.hostname} at {self.destination_ip}\"\n    )\n    return self\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.exit","title":"exit","text":"<pre><code>exit() -&gt; Union[TelnetConnection, TelnetCLIConnection]\n</code></pre> <p>Exits the current connection, but it doesn't close the socket, just returns to the previous hop.</p> <p>Returns:</p> Type Description <code>Union[TelnetConnection, TelnetCLIConnection]</code> <p>Union[TelnetConnection, TelnetCLIConnection]: The previous hop's connection object.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@Connection.check_occupied\ndef exit(self) -&gt; Union[\"TelnetConnection\", \"TelnetCLIConnection\"]:\n    \"\"\"\n    Exits the current connection, but it doesn't close the socket, just returns to the previous hop.\n\n    Returns:\n        Union[TelnetConnection, TelnetCLIConnection]: The previous hop's connection object.\n    \"\"\"\n    self.source_connection._is_occupied = False\n    # Write \"exit\" to jump back to previous hop\n    self.write_command(\n        command=\"exit\",\n        expected_prompt_pattern=[b\"closed\", b\"Connection closed by foreign host.\"],\n        timeout=self.timeout,\n    )\n    # Obligatory to return connection object because it might be of a different type\n    self._is_disconnected = True\n    logger.info(\n        f\"Jumped back to previous hop at device {self.source_connection.destination_device.hostname}\"\n    )\n    return self.source_connection\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.check_occupied","title":"check_occupied","text":"<pre><code>check_occupied(func)\n</code></pre> <p>Decorator to check if the connection is already in use and hence not available.</p> <p>This decorator is used to wrap methods that should not be executed if the connection is already in use.</p> <p>Raises:</p> Type Description <code>ConnectionRefusedError</code> <p>If the connection is already in use.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_occupied(func):\n    \"\"\"\n    Decorator to check if the connection is already in use and hence not available.\n\n    This decorator is used to wrap methods that should not be executed if the connection is already in use.\n\n    Raises:\n        ConnectionRefusedError: If the connection is already in use.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        if self._is_occupied:\n            raise ConnectionRefusedError(\n                \"This connection is already in use. Please close the connections that use it first.\"\n            )\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.check_device_type","title":"check_device_type","text":"<pre><code>check_device_type(required_type, is_root: bool = False)\n</code></pre> <p>Decorator to check the device type and connection privileges before executing a function.</p> <p>Parameters:</p> Name Type Description Default <code>required_type</code> <code>str</code> <p>The required device type for the function to be executed.</p> required <code>is_root</code> <code>bool</code> <p>If True, the function requires root privileges to be executed. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not of the required type.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If root privileges are required but the user does not have them.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_device_type(required_type, is_root: bool = False):\n    \"\"\"\n    Decorator to check the device type and connection privileges before executing a function.\n\n    Args:\n        required_type (str): The required device type for the function to be executed.\n        is_root (bool, optional): If True, the function requires root privileges to be executed. Defaults to False.\n\n    Raises:\n        ValueError: If the device is not of the required type.\n        ConnectionError: If the device is not connected.\n        PermissionError: If root privileges are required but the user does not have them.\n    \"\"\"\n\n    def decorator(func):\n        def wrapper(self, *args, **kwargs):\n            if self.destination_device.type != required_type:\n                raise ValueError(\n                    f'This method is available only for {required_type} devices, but the destination device is of type \"{self.destination_device.type}\".'\n                )\n            # Perform the connection check too, since it's a common requirement\n            if not self.is_connected:\n                raise ConnectionError(\"Device is not connected\")\n            if is_root and not self.is_root:\n                raise PermissionError(\n                    \"Root privileges required to perform this action\"\n                )\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.check_connection","title":"check_connection","text":"<pre><code>check_connection(func)\n</code></pre> <p>Decorator to check if the device is connected before executing a function.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def check_connection(func):\n    \"\"\"\n    Decorator to check if the device is connected before executing a function.\n\n    Raises:\n        ConnectionError: If the device is not connected.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        if not self.is_connected:\n            raise ConnectionError(\"Device is not connected\")\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.write_command","title":"write_command","text":"<pre><code>write_command(\n    command: str,\n    expected_prompt_pattern: Optional[List[str]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Optional[str]\n</code></pre> <p>Writes a command to the telnet connection and returns the response.</p> <p>This method sends a command to the device via the telnet connection, waits for a response, and then returns that response. The response is expected to end with a prompt symbol or match an expected pattern, which is specified by the <code>expected_prompt_pattern</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to be sent to the device.</p> required <code>expected_prompt_pattern</code> <code>Optional[List[str]]</code> <p>A list of regex patterns that the response is expected to match. If None, the method waits for the prompt symbol. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>The maximum time to wait for a response, in seconds. If None, the method uses the default timeout. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The response from the device, or None if there was no response.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the telnet connection is not established.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef write_command(\n    self,\n    command: str,\n    expected_prompt_pattern: Optional[List[str]] = None,\n    timeout: Optional[int] = None,\n) -&gt; Optional[str]:\n    \"\"\"\n    Writes a command to the telnet connection and returns the response.\n\n    This method sends a command to the device via the telnet connection, waits for a response, and then returns that response.\n    The response is expected to end with a prompt symbol or match an expected pattern, which is specified by the `expected_prompt_pattern` parameter.\n\n    Args:\n        command (str): The command to be sent to the device.\n        expected_prompt_pattern (Optional[List[str]]): A list of regex patterns that the response is expected to match. If None, the method waits for the prompt symbol. Defaults to None.\n        timeout (Optional[int]): The maximum time to wait for a response, in seconds. If None, the method uses the default timeout. Defaults to None.\n\n    Returns:\n        Optional[str]: The response from the device, or None if there was no response.\n\n    Raises:\n        ConnectionError: If the telnet connection is not established.\n    \"\"\"\n    self.flush()  # Make sure nothing is in the buffer\n\n    if self.resulting_telnet_connection is not None:\n        # If the command is a string, encode it to bytes first\n        command = (\n            command.encode(\"ascii\") + b\"\\r\"\n            if hasattr(command, \"encode\")\n            else command\n        )\n        self.resulting_telnet_connection.write(command)\n        assert self.prompt_symbol is not None, \"Prompt symbol is not defined.\"\n\n        # \"expect\" can wait for multiple patterns\n        if expected_prompt_pattern:\n            response = self.resulting_telnet_connection.expect(\n                expected_prompt_pattern,\n                timeout or self.timeout,\n            )[2]  # The third element of the tuple is the response\n        # but \"read_until\", while only for one pattern (prompt_symbol), is more reliable\n        else:\n            response = self.resulting_telnet_connection.read_until(\n                self.prompt_symbol.encode(\"ascii\"), timeout or self.timeout\n            )\n        response = response.decode(\"ascii\") if response else None\n    else:\n        raise ConnectionError(\n            \"No connection object from Telnet found during write_command.\"\n        )\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.flush","title":"flush","text":"<pre><code>flush(time_interval: int = 0.1) -&gt; None\n</code></pre> <p>This method waits for a short period of time to allow any remaining data to arrive, then reads and discards all data that has arrived at the telnet connection.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef flush(self, time_interval: int = 0.1) -&gt; None:\n    \"\"\"\n    This method waits for a short period of time to allow any remaining data to arrive,\n    then reads and discards all data that has arrived at the telnet connection.\n    \"\"\"\n    try:\n        time.sleep(time_interval)\n        if self.resulting_telnet_connection is not None:\n            self.resulting_telnet_connection.read_very_eager()\n    except EOFError as eof:\n        logger.error(\n            f\"EOFError. Usually something is wrong while loading the connection. | {eof}\"\n        )\n        raise EOFError from eof\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.read_until","title":"read_until","text":"<pre><code>read_until(\n    prompt: bytes, timeout: Optional[int] = None\n) -&gt; Optional[str]\n</code></pre> <p>Reads data from the telnet connection until a specified prompt is encountered or until timeout.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>bytes</code> <p>The prompt to read until.</p> required <code>timeout</code> <code>Optional[int]</code> <p>The maximum time to wait for the prompt, in seconds. If None, the method uses the default timeout. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The data read from the connection, or None if no data was read.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_occupied\ndef read_until(self, prompt: bytes, timeout: Optional[int] = None) -&gt; Optional[str]:\n    \"\"\"\n    Reads data from the telnet connection until a specified prompt is encountered or until timeout.\n\n    Args:\n        prompt (bytes): The prompt to read until.\n        timeout (Optional[int]): The maximum time to wait for the prompt, in seconds. If None, the method uses the default timeout. Defaults to None.\n\n    Returns:\n        Optional[str]: The data read from the connection, or None if no data was read.\n    \"\"\"\n    if timeout is not None:\n        self.timeout = timeout\n    if self.resulting_telnet_connection is not None:\n        response = self.resulting_telnet_connection.read_until(prompt, self.timeout)\n        response = response.decode(\"ascii\") if response else None\n    else:\n        raise NotImplementedError(\n            \"No connection object from Telnet found during read_until.\"\n        )\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.load_config","title":"load_config","text":"<pre><code>load_config(config_path: str) -&gt; None\n</code></pre> <p>Loads a configuration file to a OneOS device.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>The path to the configuration file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a OneOS device.</p> <code>OSError</code> <p>If the configuration file fails to open (might not exist).</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef load_config(self, config_path: str) -&gt; None:\n    \"\"\"\n    Loads a configuration file to a OneOS device.\n\n    Args:\n        config_path (str): The path to the configuration file.\n\n    Raises:\n        ValueError: If the device is not a OneOS device.\n        OSError: If the configuration file fails to open (might not exist).\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(f\"Loading config {config_path.split('/')[-1]} ...\")\n    self.write_command(\"term len 0\")\n    with open(config_path) as fp:\n        for line in fp:\n            if line.strip().startswith(\"!\"):\n                continue  # Skip comment lines\n            if \"hostname\" in line:\n                self.destination_device.hostname = line.split()[-1]\n            response = self.write_command(line)\n\n    # Check that prompt has exited config terminal fully. Search for \"localhost#\" (default) or \"&lt;configured_hostname&gt;#\"\n    self.prompt_symbol = f\"{self.destination_device.hostname}#\"\n    response = self.write_command(\"\\n\").strip()\n    if response != self.prompt_symbol:\n        logger.warning(\n            f\"Loading config might have failed, prompt is not as expected. Received {response} but expected {self.prompt_symbol} instead\"\n        )\n        logger.debug(\n            'Sometimes the developer has miscalculated the \"exit\" commands in the BSA'\n        )\n        self.write_command(\"end\")\n    logger.info(\n        f\"Loaded configuration to device {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.set_sudo","title":"set_sudo","text":"<pre><code>set_sudo(root_password: Optional[str] = None) -&gt; None\n</code></pre> <p>Sets sudo privileges for a Linux device. The prompt symbol is updated to '#' to reflect the change to the root user.</p> <p>Parameters:</p> Name Type Description Default <code>root_password</code> <code>Optional[str]</code> <p>The root password. If None, the method uses the password of the destination device. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a Linux device.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>AssertionError</code> <p>If the method fails to switch to the root user.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\")\ndef set_sudo(self, root_password: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Sets sudo privileges for a Linux device.\n    The prompt symbol is updated to '#' to reflect the change to the root user.\n\n    Args:\n        root_password (Optional[str]): The root password. If None, the method uses the password of the destination device. Defaults to None.\n\n    Raises:\n        ValueError: If the device is not a Linux device.\n        ConnectionError: If the device is not connected.\n        AssertionError: If the method fails to switch to the root user.\n    \"\"\"\n    if root_password is None:\n        root_password = self.destination_device.password\n    self.write_command(\"sudo su\", expected_prompt_pattern=[b\"password for user:\"])\n    self.write_command(root_password, expected_prompt_pattern=[b\"#\"])\n    self.prompt_symbol = \"#\"  # In Linux, changes from '$' to '#' if root\n    assert self.is_root, \"Failed to identify root user\"\n    logger.info(\n        f\"Sudo privileges set for linux device: {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.set_interface_ip","title":"set_interface_ip","text":"<pre><code>set_interface_ip(\n    interface_name: str,\n    ip_addr: str,\n    netmask: str = \"24\",\n    interface_state: str = \"up\",\n) -&gt; None\n</code></pre> <p>Sets the IP address, netmask, and state of a specified interface on a Linux device.</p> <p>Parameters:</p> Name Type Description Default <code>interface_name</code> <code>str</code> <p>The name of the interface.</p> required <code>ip_addr</code> <code>str</code> <p>The IP address to set.</p> required <code>netmask</code> <code>str</code> <p>The netmask to set. Defaults to \"24\".</p> <code>'24'</code> <code>interface_state</code> <code>str</code> <p>The state of the interface. Must be 'up' or 'down'. Defaults to \"up\".</p> <code>'up'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the IP address is invalid, if the interface does not exist or if the device type is not Linux.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If the user does not have root privileges.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\", is_root=True)\ndef set_interface_ip(\n    self,\n    interface_name: str,\n    ip_addr: str,\n    netmask: str = \"24\",\n    interface_state: str = \"up\",\n) -&gt; None:\n    \"\"\"\n    Sets the IP address, netmask, and state of a specified interface on a Linux device.\n\n    Args:\n        interface_name (str): The name of the interface.\n        ip_addr (str): The IP address to set.\n        netmask (str, optional): The netmask to set. Defaults to \"24\".\n        interface_state (str, optional): The state of the interface. Must be 'up' or 'down'. Defaults to \"up\".\n\n    Raises:\n        ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n        ConnectionError: If the device is not connected.\n        PermissionError: If the user does not have root privileges.\n    \"\"\"\n    if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n        raise ValueError(\"Invalid IP address.\")\n    if interface_state not in [\"up\", \"down\"]:\n        logger.error(\n            f\"Invalid state: {interface_state}. Must be 'up' or 'down'. Passing 'up' by default.\"\n        )\n        interface_state = \"up\"\n    if self._get_interface(interface_name) is None:\n        raise ValueError(f\"Interface {interface_name} not found\")\n    self.write_command(f\"ip addr add {ip_addr}/{netmask} dev {interface_name}\")\n    self.write_command(f\"ip link set {interface_name} {interface_state}\")\n    logger.info(\n        f\"Interface {interface_name} set to IP {ip_addr} with netmask {netmask} and state {interface_state}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.delete_interface_ip","title":"delete_interface_ip","text":"<pre><code>delete_interface_ip(\n    interface_name: str, ip_addr: str, netmask: str = \"24\"\n) -&gt; None\n</code></pre> <p>Deletes the IP address from a specified interface on a Linux device.</p> <p>Parameters:</p> Name Type Description Default <code>interface_name</code> <code>str</code> <p>The name of the interface.</p> required <code>ip_addr</code> <code>str</code> <p>The IP address to delete.</p> required <code>netmask</code> <code>str</code> <p>The netmask of the IP address. Defaults to \"24\".</p> <code>'24'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the IP address is invalid, if the interface does not exist or if the device type is not Linux.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> <code>PermissionError</code> <p>If the user does not have root privileges.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\", is_root=True)\ndef delete_interface_ip(\n    self, interface_name: str, ip_addr: str, netmask: str = \"24\"\n) -&gt; None:\n    \"\"\"\n    Deletes the IP address from a specified interface on a Linux device.\n\n    Args:\n        interface_name (str): The name of the interface.\n        ip_addr (str): The IP address to delete.\n        netmask (str, optional): The netmask of the IP address. Defaults to \"24\".\n\n    Raises:\n        ValueError: If the IP address is invalid, if the interface does not exist or if the device type is not Linux.\n        ConnectionError: If the device is not connected.\n        PermissionError: If the user does not have root privileges.\n    \"\"\"\n    if not re.match(r\"\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b\", ip_addr):\n        raise ValueError(\"Invalid IP address.\")\n    if self._get_interface(interface_name) is None:\n        raise ValueError(f\"Interface {interface_name} not found\")\n    self.write_command(f\"ip addr del {ip_addr}/{netmask} dev {interface_name}\")\n    logger.info(\n        f\"IP {ip_addr} with netmask {netmask} deleted from interface {interface_name}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.unload_interface","title":"unload_interface","text":"<pre><code>unload_interface(\n    interface_line: str, wrap_command: bool = True\n) -&gt; Optional[str]\n</code></pre> <p>Resets the configuration of a specified interface to its default settings. OneOS6 WARNING: \"By configuring the interface back to default, it is possible that some services will not work any more\"</p> <p>Parameters:</p> Name Type Description Default <code>interface_line</code> <code>str</code> <p>The line of the full interface name to reset (i.e. interface gigabitethernet 0/0).</p> required <code>wrap_command</code> <code>bool</code> <p>If True, the method enters and exits the \"configure terminal\" command.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The response from the device after sending the 'default' command, or None if there was no response.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef unload_interface(\n    self, interface_line: str, wrap_command: bool = True\n) -&gt; Optional[str]:\n    \"\"\"\n    Resets the configuration of a specified interface to its default settings.\n    OneOS6 WARNING: \"By configuring the interface back to default, it is possible that some services will not work any more\"\n\n    Args:\n        interface_line (str): The line of the full interface name to reset (i.e. interface gigabitethernet 0/0).\n        wrap_command (bool, optional): If True, the method enters and exits the \"configure terminal\" command.\n\n    Returns:\n        Optional[str]: The response from the device after sending the 'default' command, or None if there was no response.\n    \"\"\"\n    self.write_command(\"config terminal\") if wrap_command else None\n    response = self.write_command(f\"default {interface_line}\")\n    self.write_command(\"end\") if wrap_command else None\n    return response\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.unload_config","title":"unload_config","text":"<pre><code>unload_config(\n    unload_specific_commands: Optional[List[str]] = None,\n    check_is_empty: bool = False,\n) -&gt; None\n</code></pre> <p>Unloads the configuration of the device using a bottom-up approach. The configurations on the bottom of the config inherit properties from the configurations above them.</p> <p>Sometimes, even by that approach, some commands cannot be unloaded. In that case, the user must manually unload them,     by providing the no-commands in the unload_specific_commands parameter.</p> <p>The config is retrieved by the very slow \"show running-config\" command. If check_is_empty is True,     \"show running-config\" is called again (another couple of seconds wait time), that's why default is to not check.</p> <p>Parameters:</p> Name Type Description Default <code>unload_specific_commands</code> <code>Optional[List[str]]</code> <p>A list of specific commands to unload. Defaults to None.</p> <code>None</code> <code>check_is_empty</code> <code>bool</code> <p>If True, the method checks if the configuration is empty after unloading. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration is not fully unloaded and check_is_empty is True, or if device type is not oneos.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef unload_config(\n    self,\n    unload_specific_commands: Optional[List[str]] = None,\n    check_is_empty: bool = False,\n) -&gt; None:\n    \"\"\"\n    Unloads the configuration of the device using a bottom-up approach.\n    The configurations on the bottom of the config inherit properties from the configurations above them.\n\n    Sometimes, even by that approach, some commands cannot be unloaded. In that case, the user must manually unload them,\n        by providing the no-commands in the unload_specific_commands parameter.\n\n    The config is retrieved by the very slow \"show running-config\" command. If check_is_empty is True,\n        \"show running-config\" is called again (another couple of seconds wait time), that's why default is to not check.\n\n    Args:\n        unload_specific_commands (Optional[List[str]]): A list of specific commands to unload. Defaults to None.\n        check_is_empty (bool, optional): If True, the method checks if the configuration is empty after unloading. Defaults to False.\n\n    Raises:\n        ValueError: If the configuration is not fully unloaded and check_is_empty is True, or if device type is not oneos.\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(\n        f\"Unloading config for device {self.destination_device.hostname} ...\"\n    )\n    self.write_command(\"term len 0\")\n    self.flush()\n\n    config_lines = self.write_command(\"show running-config\").split(\"\\n\")\n    config_lines_reverse = config_lines[::-1]  # Traverse from bottom to top\n\n    self.prompt_symbol = \"#\"\n    self.write_command(\"config terminal\")\n\n    # Unload ip routes\n    for line in config_lines_reverse:\n        if re.search(r\"^(ip(v6|) (route|host)|aaa authentication login)\", line):\n            self.write_command(f\"no {line}\")\n        elif re.search(r\"^radius-server\", line):\n            self.write_command(f\"no radius-server {line.split(' ')[1]}\")\n        if \"exit\" in line:\n            break\n\n    # Unload interfaces\n    for line in config_lines_reverse:\n        if line.startswith(\"interface\"):\n            # If any of the interfaces listed in permanent_interfaces is a substring of the line\n            if any(\n                interface in line\n                for interface in self.destination_device.PHYSICAL_INTERFACES_LIST\n            ):\n                self.unload_interface(line, wrap_command=False)\n            else:\n                self.write_command(f\"no {line}\")\n\n    # Get all the lines until the first interface\n    interface_index = next(\n        (i for i, line in enumerate(config_lines) if line.startswith(\"interface\")),\n        None,\n    )\n    config_lines_until_interfaces = config_lines[:interface_index]\n    # Get all the lines that are not preceded with space -&gt; assumes that they are unloaded as part of the main line unload\n    main_lines = [\n        line\n        for line in config_lines_until_interfaces\n        if (not line.startswith(\" \") and \"exit\" not in line)\n    ]\n    for line in main_lines[:1:-1]:  # Traverse from bottom to top again\n        if \"license activate\" in line:\n            continue\n        # NOTE: Ignore cases that the \"no\" prefix will not work, expect the user to manually unload these in the loop below\n        self.write_command(f\"no {line}\")\n\n    # Finally, if user knows that there are configuration leftovers, unload it manually\n    if unload_specific_commands is not None:\n        for command in unload_specific_commands:\n            self.write_command(command)\n\n    self.write_command(\"hostname localhost\")\n    self.write_command(\"end\")\n    self.flush()\n\n    # NOTE: By default, keep check to False because \"show running-config\" takes ~4s to return response\n    if check_is_empty and not self.is_config_empty(\n        self.write_command(\"show running-config\")\n    ):\n        logger.error(\n            f\"Config not fully unloaded for device {self.destination_device.hostname}\"\n        )\n        return\n    logger.info(\n        f\"Config unloading effort finished for device {self.destination_device.hostname}\"\n    )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.is_config_empty","title":"is_config_empty","text":"<pre><code>is_config_empty(\n    configuration: str,\n    except_lines: Optional[List[str]] = None,\n) -&gt; bool\n</code></pre> <p>Checks if the configuration of the device is fully empty and return boolean.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>def is_config_empty(\n    self, configuration: str, except_lines: Optional[List[str]] = None\n) -&gt; bool:\n    \"\"\"\n    Checks if the configuration of the device is fully empty and return boolean.\n    \"\"\"\n    config_lines = configuration.split(\"\\n\")\n    if (\n        \"show running-config\" not in config_lines[0]\n        or \"localhost#\" not in config_lines[-1]\n    ):\n        logger.debug(f\"Returned config is not okay: {config_lines}\")\n        return False\n\n    # Remove lines that should not be checked (lines in `except_lines` list)\n    config_lines = [\n        line\n        for line in config_lines\n        if all(exception not in line for exception in except_lines)\n    ]\n\n    # Ensure empty interfaces pattern\n    interface_lines = config_lines[1:-1]\n    for i in range(len(interface_lines)):\n        if i % 2 == 0:\n            line = interface_lines[i].split()\n            if (\n                line[0] != \"interface\"\n                or line[1] not in self.destination_device.PHYSICAL_INTERFACES_LIST\n            ):\n                return False\n        else:\n            if \"exit\" not in interface_lines[i]:\n                return False\n    return True\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.ping","title":"ping","text":"<pre><code>ping(\n    ip: str, nbr_packets: int = 1, ping_timeout: int = 1\n) -&gt; str\n</code></pre> <p>Sends a ping command to a specified IP address from the device. Supports both Linux and OneOS devices.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_connection\ndef ping(self, ip: str, nbr_packets: int = 1, ping_timeout: int = 1) -&gt; str:\n    \"\"\"\n    Sends a ping command to a specified IP address from the device.\n    Supports both Linux and OneOS devices.\n    \"\"\"\n    if self.destination_device.type == \"oneos\":\n        response = self.write_command(\n            f\"ping {ip} -n {nbr_packets} -w {ping_timeout}\"\n        )\n        logger.info(f\"Ping {nbr_packets * 5} packets at IP: {ip}\")\n        return response\n    elif self.destination_device.type == \"linux\":\n        response = self.write_command(\n            f\"ping {ip} -c {nbr_packets} -W {ping_timeout}\"\n        )\n        logger.info(f\"Ping {nbr_packets} packets at IP: {ip}\")\n        return response\n    else:\n        raise NotImplementedError(\n            f\"Ping not implemented for device type {self.destination_device.type}\"\n        )\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.hping3","title":"hping3","text":"<pre><code>hping3(\n    destination_ip: str,\n    nbr_packets: Optional[int] = None,\n    interval: Optional[str] = None,\n    flood: bool = False,\n    port: Optional[int] = None,\n    type: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Execute hping3 command on the Linux device. For more information about hping3, see https://linux.die.net/man/8/hping3</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"linux\")\ndef hping3(\n    self,\n    destination_ip: str,\n    nbr_packets: Optional[int] = None,\n    interval: Optional[str] = None,\n    flood: bool = False,\n    port: Optional[int] = None,\n    type: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Execute hping3 command on the Linux device.\n    For more information about hping3, see https://linux.die.net/man/8/hping3\n    \"\"\"\n    valid_types = [\"tcp\", \"udp\", \"icmp\", \"rawip\", \"syn\", \"ack\", \"fin\", \"rst\"]\n    full_command = \"hping3 \"\n    if nbr_packets is not None:\n        full_command += f\"-c {nbr_packets} \"\n    if interval is not None:\n        full_command += f\"-i {interval} \"\n    if flood:\n        full_command += \"--flood \"\n    if port is not None:\n        full_command += f\"-p {port} \"\n    if type is not None and type.lower() in valid_types:\n        full_command += f\"--{type} \"\n    self.write_command(full_command + destination_ip)\n</code></pre>"},{"location":"api/connection/#router_test_kit.connection.TelnetCLIConnection.reconfigure","title":"reconfigure","text":"<pre><code>reconfigure(commands_list: List[str]) -&gt; None\n</code></pre> <p>Reconfigures a OneOS device with a list of commands. The list of commands is expected to include the exact commands     to be sent to the device, with their \"exit\" commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands_list</code> <code>List[str]</code> <p>The list of commands to send to the device, excluding the \"config terminal\" and \"end\" commands.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the device is not a OneOS device.</p> <code>ConnectionError</code> <p>If the device is not connected.</p> Source code in <code>src/router_test_kit/connection.py</code> <pre><code>@check_device_type(\"oneos\")\ndef reconfigure(self, commands_list: List[str]) -&gt; None:\n    \"\"\"\n    Reconfigures a OneOS device with a list of commands.\n    The list of commands is expected to include the exact commands\n        to be sent to the device, with their \"exit\" commands.\n\n    Args:\n        commands_list (List[str]): The list of commands to send to the device, excluding the \"config terminal\" and \"end\" commands.\n\n    Raises:\n        ValueError: If the device is not a OneOS device.\n        ConnectionError: If the device is not connected.\n    \"\"\"\n    logger.debug(\"Reconfiguring device ...\")\n    self.write_command(\"term len 0\")\n    self.write_command(\"config terminal\")\n    for command in commands_list:\n        self.write_command(command)\n    self.write_command(\"end\")\n    self.flush()\n    logger.debug(f\"reconfig commands: {' | '.join(commands_list)}\")\n    logger.info(\"Device reconfigured\")\n</code></pre>"},{"location":"api/device/","title":"Device API","text":"<p>The device module provides device abstraction classes for different types of network devices and hosts.</p> <p>Device Management Module.</p> <p>This module provides device abstraction classes that represent different types of network devices and hosts. Each device class encapsulates device-specific information such as credentials, hostnames, and device type characteristics.</p> <p>The module implements a device hierarchy with an abstract base class and concrete implementations for different device types:</p> <ul> <li>Device (ABC): Abstract base class defining the device interface</li> <li>LinuxDevice: Represents Linux-based network devices and hosts</li> <li>OneOS6Device: Represents OneOS6 router/switch devices  </li> <li>RADIUSServer: Specialized Linux device for RADIUS authentication</li> <li>HostDevice: Utility class for executing commands on the local host</li> </ul> <p>Classes:</p> Name Description <code>Device</code> <p>Abstract base class for all device types</p> <code>LinuxDevice</code> <p>Linux/Unix-based device implementation</p> <code>OneOS6Device</code> <p>OneOS6 network device implementation</p> <code>RADIUSServer</code> <p>RADIUS server device (extends LinuxDevice)</p> <code>HostDevice</code> <p>Local host command execution utility</p> Example <p>Basic device usage:</p> <pre><code>from router_test_kit.device import LinuxDevice, OneOS6Device\n\n# Create different device types\nlinux_vm = LinuxDevice(username=\"admin\", password=\"secret\")\nrouter = OneOS6Device(username=\"admin\", password=\"admin\")\n\n# Device types are automatically set\nprint(linux_vm.type)  # \"linux\"\nprint(router.type)    # \"oneos\"\n</code></pre> Note <p>Device objects store connection credentials but do not manage connections themselves. Connections are handled by the Connection classes which use Device objects to obtain authentication information.</p>"},{"location":"api/device/#router_test_kit.device-classes","title":"Classes","text":""},{"location":"api/device/#router_test_kit.device.Device","title":"Device","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for network devices and hosts.</p> <p>This class provides a common interface for all device types, storing essential information such as credentials, hostname, and device type. Device objects are used by Connection classes to obtain authentication information and device-specific characteristics.</p> <p>Each device subclass defines default values for username, password, and prompt symbols that are appropriate for that device type. These defaults can be overridden during instantiation.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>Optional[str]</code> <p>Authentication username for the device</p> <code>password</code> <code>Optional[str]</code> <p>Authentication password for the device  </p> <code>hostname</code> <code>Optional[str]</code> <p>Network hostname or identifier</p> <code>type</code> <code>str</code> <p>Device type identifier (read-only property)</p> Class Attributes <p>DEFAULT_USERNAME (str): Default username for this device type DEFAULT_PASSWORD (str): Default password for this device type DEFAULT_PROMPT_SYMBOL (str): Default command prompt symbol</p> Example <p>This is an abstract class and cannot be instantiated directly:</p> <pre><code># Use concrete implementations instead\ndevice = LinuxDevice(username=\"admin\", password=\"secret\")\nprint(device.type)  # \"linux\"\n</code></pre> Note <p>Device objects are passive containers for device information. They do not establish or manage network connections. Use Connection classes for actual network communication.</p> Source code in <code>src/router_test_kit/device.py</code> <pre><code>class Device(ABC):\n    \"\"\"Abstract base class for network devices and hosts.\n\n    This class provides a common interface for all device types, storing essential\n    information such as credentials, hostname, and device type. Device objects are\n    used by Connection classes to obtain authentication information and device-specific\n    characteristics.\n\n    Each device subclass defines default values for username, password, and prompt\n    symbols that are appropriate for that device type. These defaults can be\n    overridden during instantiation.\n\n    Attributes:\n        username (Optional[str]): Authentication username for the device\n        password (Optional[str]): Authentication password for the device  \n        hostname (Optional[str]): Network hostname or identifier\n        type (str): Device type identifier (read-only property)\n\n    Class Attributes:\n        DEFAULT_USERNAME (str): Default username for this device type\n        DEFAULT_PASSWORD (str): Default password for this device type\n        DEFAULT_PROMPT_SYMBOL (str): Default command prompt symbol\n\n    Example:\n        This is an abstract class and cannot be instantiated directly:\n\n        ```python\n        # Use concrete implementations instead\n        device = LinuxDevice(username=\"admin\", password=\"secret\")\n        print(device.type)  # \"linux\"\n        ```\n\n    Note:\n        Device objects are passive containers for device information. They do not\n        establish or manage network connections. Use Connection classes for actual\n        network communication.\n    \"\"\"\n\n    # Default values to be overridden by subclasses\n    DEFAULT_USERNAME: str = \"\"\n    DEFAULT_PASSWORD: str = \"\"\n    DEFAULT_PROMPT_SYMBOL: str = \"\"\n\n    def __init__(self, username: Optional[str] = None, password: Optional[str] = None):\n        \"\"\"Initialize a new device instance.\n\n        Args:\n            username: Authentication username. Uses class default if None.\n            password: Authentication password. Uses class default if None.\n\n        Note:\n            This is an abstract class and should not be instantiated directly.\n            Use concrete implementations like LinuxDevice or OneOS6Device.\n        \"\"\"\n        self.username = username\n        self.password = password\n        self.hostname = None\n        self._type = \"device\"\n\n    @property\n    def type(self) -&gt; str:\n        \"\"\"Get the device type identifier.\n\n        Returns:\n            str: Device type string (e.g., \"linux\", \"oneos\")\n        \"\"\"\n        return self._type\n</code></pre>"},{"location":"api/device/#router_test_kit.device.Device-attributes","title":"Attributes","text":""},{"location":"api/device/#router_test_kit.device.Device.type","title":"type  <code>property</code>","text":"<pre><code>type: str\n</code></pre> <p>Get the device type identifier.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Device type string (e.g., \"linux\", \"oneos\")</p>"},{"location":"api/device/#router_test_kit.device.Device-functions","title":"Functions","text":""},{"location":"api/device/#router_test_kit.device.Device.__init__","title":"__init__","text":"<pre><code>__init__(\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n)\n</code></pre> <p>Initialize a new device instance.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>Optional[str]</code> <p>Authentication username. Uses class default if None.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>Authentication password. Uses class default if None.</p> <code>None</code> Note <p>This is an abstract class and should not be instantiated directly. Use concrete implementations like LinuxDevice or OneOS6Device.</p> Source code in <code>src/router_test_kit/device.py</code> <pre><code>def __init__(self, username: Optional[str] = None, password: Optional[str] = None):\n    \"\"\"Initialize a new device instance.\n\n    Args:\n        username: Authentication username. Uses class default if None.\n        password: Authentication password. Uses class default if None.\n\n    Note:\n        This is an abstract class and should not be instantiated directly.\n        Use concrete implementations like LinuxDevice or OneOS6Device.\n    \"\"\"\n    self.username = username\n    self.password = password\n    self.hostname = None\n    self._type = \"device\"\n</code></pre>"},{"location":"api/device/#router_test_kit.device.LinuxDevice","title":"LinuxDevice","text":"<p>               Bases: <code>Device</code></p> <p>Linux/Unix-based device implementation.</p> <p>Represents Linux, Unix, or other POSIX-compatible devices and virtual machines. This class is commonly used for Linux-based network appliances, virtual machines, and general-purpose Linux hosts.</p> <p>The class provides appropriate defaults for Linux systems: - Default username: \"user\" - Default password: \"user\" - Default prompt: \"$\" (changes to \"#\" for root)</p> <p>Attributes:</p> Name Type Description <code>All</code> <code>attributes inherited from Device class, plus</code> <code>hostname</code> <code>str</code> <p>Auto-generated hostname in format \"linux-{username}\"</p> Example <pre><code># Use defaults\nvm = LinuxDevice()\nprint(vm.username)  # \"user\"\nprint(vm.hostname)  # \"linux-user\"\n\n# Custom credentials\nvm = LinuxDevice(username=\"admin\", password=\"secret\")\nprint(vm.hostname)  # \"linux-admin\"\n</code></pre> Source code in <code>src/router_test_kit/device.py</code> <pre><code>class LinuxDevice(Device):\n    \"\"\"Linux/Unix-based device implementation.\n\n    Represents Linux, Unix, or other POSIX-compatible devices and virtual machines.\n    This class is commonly used for Linux-based network appliances, virtual machines,\n    and general-purpose Linux hosts.\n\n    The class provides appropriate defaults for Linux systems:\n    - Default username: \"user\"\n    - Default password: \"user\"  \n    - Default prompt: \"$\" (changes to \"#\" for root)\n\n    Attributes:\n        All attributes inherited from Device class, plus:\n        hostname (str): Auto-generated hostname in format \"linux-{username}\"\n\n    Example:\n        ```python\n        # Use defaults\n        vm = LinuxDevice()\n        print(vm.username)  # \"user\"\n        print(vm.hostname)  # \"linux-user\"\n\n        # Custom credentials\n        vm = LinuxDevice(username=\"admin\", password=\"secret\")\n        print(vm.hostname)  # \"linux-admin\"\n        ```\n    \"\"\"\n    DEFAULT_USERNAME = \"user\"\n    DEFAULT_PASSWORD = \"user\"\n    DEFAULT_PROMPT_SYMBOL = \"$\"  # Changes to '#' if root\n\n    def __init__(self, username: Optional[str] = None, password: Optional[str] = None):\n        \"\"\"Initialize a Linux device.\n\n        Args:\n            username: Linux username. Defaults to \"user\" if None.\n            password: Linux password. Defaults to \"user\" if None.\n        \"\"\"\n        username = username if username else self.DEFAULT_USERNAME\n        password = password if password else self.DEFAULT_PASSWORD\n        super().__init__(username, password)\n        self._type = \"linux\"\n        self.hostname = f\"{self._type}-{username or self.DEFAULT_USERNAME}\"\n</code></pre>"},{"location":"api/device/#router_test_kit.device.LinuxDevice-attributes","title":"Attributes","text":""},{"location":"api/device/#router_test_kit.device.LinuxDevice.type","title":"type  <code>property</code>","text":"<pre><code>type: str\n</code></pre> <p>Get the device type identifier.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Device type string (e.g., \"linux\", \"oneos\")</p>"},{"location":"api/device/#router_test_kit.device.LinuxDevice-functions","title":"Functions","text":""},{"location":"api/device/#router_test_kit.device.LinuxDevice.__init__","title":"__init__","text":"<pre><code>__init__(\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n)\n</code></pre> <p>Initialize a Linux device.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>Optional[str]</code> <p>Linux username. Defaults to \"user\" if None.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>Linux password. Defaults to \"user\" if None.</p> <code>None</code> Source code in <code>src/router_test_kit/device.py</code> <pre><code>def __init__(self, username: Optional[str] = None, password: Optional[str] = None):\n    \"\"\"Initialize a Linux device.\n\n    Args:\n        username: Linux username. Defaults to \"user\" if None.\n        password: Linux password. Defaults to \"user\" if None.\n    \"\"\"\n    username = username if username else self.DEFAULT_USERNAME\n    password = password if password else self.DEFAULT_PASSWORD\n    super().__init__(username, password)\n    self._type = \"linux\"\n    self.hostname = f\"{self._type}-{username or self.DEFAULT_USERNAME}\"\n</code></pre>"},{"location":"api/device/#router_test_kit.device.RADIUSServer","title":"RADIUSServer","text":"<p>               Bases: <code>LinuxDevice</code></p> <p>RADIUS authentication server device.</p> <p>Specialized Linux device for RADIUS (Remote Authentication Dial-In User Service) servers. Inherits all Linux device functionality but uses a specific hostname identifier for RADIUS services.</p> <p>This class is typically used in network testing scenarios that require authentication services for devices like routers and switches.</p> Example <pre><code>radius = RADIUSServer(username=\"radius_admin\", password=\"secret\")\nprint(radius.hostname)  # \"radius-server\"\nprint(radius.type)      # \"linux\"\n</code></pre> Source code in <code>src/router_test_kit/device.py</code> <pre><code>class RADIUSServer(LinuxDevice):\n    \"\"\"RADIUS authentication server device.\n\n    Specialized Linux device for RADIUS (Remote Authentication Dial-In User Service)\n    servers. Inherits all Linux device functionality but uses a specific hostname\n    identifier for RADIUS services.\n\n    This class is typically used in network testing scenarios that require\n    authentication services for devices like routers and switches.\n\n    Example:\n        ```python\n        radius = RADIUSServer(username=\"radius_admin\", password=\"secret\")\n        print(radius.hostname)  # \"radius-server\"\n        print(radius.type)      # \"linux\"\n        ```\n    \"\"\"\n\n    def __init__(self, username: Optional[str] = None, password: Optional[str] = None):\n        \"\"\"Initialize a RADIUS server device.\n\n        Args:\n            username: RADIUS server admin username. Defaults to \"user\" if None.\n            password: RADIUS server admin password. Defaults to \"user\" if None.\n        \"\"\"\n        super().__init__(username, password)\n        self.hostname = \"radius-server\"\n</code></pre>"},{"location":"api/device/#router_test_kit.device.RADIUSServer-attributes","title":"Attributes","text":""},{"location":"api/device/#router_test_kit.device.RADIUSServer.type","title":"type  <code>property</code>","text":"<pre><code>type: str\n</code></pre> <p>Get the device type identifier.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Device type string (e.g., \"linux\", \"oneos\")</p>"},{"location":"api/device/#router_test_kit.device.RADIUSServer-functions","title":"Functions","text":""},{"location":"api/device/#router_test_kit.device.RADIUSServer.__init__","title":"__init__","text":"<pre><code>__init__(\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n)\n</code></pre> <p>Initialize a RADIUS server device.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>Optional[str]</code> <p>RADIUS server admin username. Defaults to \"user\" if None.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>RADIUS server admin password. Defaults to \"user\" if None.</p> <code>None</code> Source code in <code>src/router_test_kit/device.py</code> <pre><code>def __init__(self, username: Optional[str] = None, password: Optional[str] = None):\n    \"\"\"Initialize a RADIUS server device.\n\n    Args:\n        username: RADIUS server admin username. Defaults to \"user\" if None.\n        password: RADIUS server admin password. Defaults to \"user\" if None.\n    \"\"\"\n    super().__init__(username, password)\n    self.hostname = \"radius-server\"\n</code></pre>"},{"location":"api/device/#router_test_kit.device.OneOS6Device","title":"OneOS6Device","text":"<p>               Bases: <code>Device</code></p> <p>OneOS6 network device implementation.</p> <p>Represents OneOS6-based routers and switches. OneOS6 is a network operating system commonly used in enterprise routing and switching equipment.</p> <p>The class provides appropriate defaults for OneOS6 devices: - Default username: \"admin\" - Default password: \"admin\" - Default prompt: \"#\" (privileged mode)</p> <p>Attributes:</p> Name Type Description <code>All</code> <code>attributes inherited from Device class, plus</code> <code>PHYSICAL_INTERFACES_LIST</code> <code>List[str]</code> <p>Supported interface types</p> Class Attributes <p>PHYSICAL_INTERFACES_LIST: List of supported physical interface types that can be extended based on specific device models</p> Example <pre><code># Use defaults\nrouter = OneOS6Device()\nprint(router.username)  # \"admin\"\nprint(router.type)      # \"oneos\"\n\n# Check supported interfaces\nprint(router.PHYSICAL_INTERFACES_LIST)\n# [\"gigabitethernet\", \"fastethernet\"]\n</code></pre> Note <p>The PHYSICAL_INTERFACES_LIST can be extended in subclasses to support additional interface types for specific OneOS6 device models.</p> Source code in <code>src/router_test_kit/device.py</code> <pre><code>class OneOS6Device(Device):\n    \"\"\"OneOS6 network device implementation.\n\n    Represents OneOS6-based routers and switches. OneOS6 is a network operating\n    system commonly used in enterprise routing and switching equipment.\n\n    The class provides appropriate defaults for OneOS6 devices:\n    - Default username: \"admin\"\n    - Default password: \"admin\"\n    - Default prompt: \"#\" (privileged mode)\n\n    Attributes:\n        All attributes inherited from Device class, plus:\n        PHYSICAL_INTERFACES_LIST (List[str]): Supported interface types\n\n    Class Attributes:\n        PHYSICAL_INTERFACES_LIST: List of supported physical interface types\n        that can be extended based on specific device models\n\n    Example:\n        ```python\n        # Use defaults\n        router = OneOS6Device()\n        print(router.username)  # \"admin\"\n        print(router.type)      # \"oneos\"\n\n        # Check supported interfaces\n        print(router.PHYSICAL_INTERFACES_LIST)\n        # [\"gigabitethernet\", \"fastethernet\"]\n        ```\n\n    Note:\n        The PHYSICAL_INTERFACES_LIST can be extended in subclasses to support\n        additional interface types for specific OneOS6 device models.\n    \"\"\"\n    DEFAULT_USERNAME = \"admin\"\n    DEFAULT_PASSWORD = \"admin\"\n    DEFAULT_PROMPT_SYMBOL = \"#\"\n\n    # To be extended by use-case with more interfaces\n    PHYSICAL_INTERFACES_LIST = [\n        \"gigabitethernet\",\n        \"fastethernet\",\n    ]\n\n    def __init__(self, username: Optional[str] = None, password: Optional[str] = None):\n        \"\"\"Initialize a OneOS6 device.\n\n        Args:\n            username: OneOS6 admin username. Defaults to \"admin\" if None.\n            password: OneOS6 admin password. Defaults to \"admin\" if None.\n        \"\"\"\n        username = username if username else self.DEFAULT_USERNAME\n        password = password if password else self.DEFAULT_PASSWORD\n        super().__init__(username, password)\n        self._type = \"oneos\"\n        self.hostname = \"localhost\"\n</code></pre>"},{"location":"api/device/#router_test_kit.device.OneOS6Device-attributes","title":"Attributes","text":""},{"location":"api/device/#router_test_kit.device.OneOS6Device.type","title":"type  <code>property</code>","text":"<pre><code>type: str\n</code></pre> <p>Get the device type identifier.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Device type string (e.g., \"linux\", \"oneos\")</p>"},{"location":"api/device/#router_test_kit.device.OneOS6Device-functions","title":"Functions","text":""},{"location":"api/device/#router_test_kit.device.OneOS6Device.__init__","title":"__init__","text":"<pre><code>__init__(\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n)\n</code></pre> <p>Initialize a OneOS6 device.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>Optional[str]</code> <p>OneOS6 admin username. Defaults to \"admin\" if None.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>OneOS6 admin password. Defaults to \"admin\" if None.</p> <code>None</code> Source code in <code>src/router_test_kit/device.py</code> <pre><code>def __init__(self, username: Optional[str] = None, password: Optional[str] = None):\n    \"\"\"Initialize a OneOS6 device.\n\n    Args:\n        username: OneOS6 admin username. Defaults to \"admin\" if None.\n        password: OneOS6 admin password. Defaults to \"admin\" if None.\n    \"\"\"\n    username = username if username else self.DEFAULT_USERNAME\n    password = password if password else self.DEFAULT_PASSWORD\n    super().__init__(username, password)\n    self._type = \"oneos\"\n    self.hostname = \"localhost\"\n</code></pre>"},{"location":"api/device/#router_test_kit.device.HostDevice","title":"HostDevice","text":"<p>Local host command execution utility.</p> <p>This class provides static methods for executing shell commands on the local host system. It's designed for scenarios where tests need to run commands on the host machine running the test suite.</p> <p>The class uses the modern subprocess.run API with proper error handling, timeout support, and flexible output management.</p> Example <pre><code># Basic command execution\nresult = HostDevice.write_command(\"echo 'Hello World'\")\nprint(result)  # \"Hello World\"\n\n# With error handling\nresult = HostDevice.write_command(\"nonexistent_command\", quiet=True)\nprint(result)  # None (command failed)\n\n# With logging\nresult = HostDevice.write_command(\"ls -la\", print_response=True)\n# Logs command execution details\n</code></pre> Note <p>All methods are static since this class doesn't maintain state. Commands are executed with a 30-second timeout by default.</p> Source code in <code>src/router_test_kit/device.py</code> <pre><code>class HostDevice:\n    \"\"\"Local host command execution utility.\n\n    This class provides static methods for executing shell commands on the local\n    host system. It's designed for scenarios where tests need to run commands\n    on the host machine running the test suite.\n\n    The class uses the modern subprocess.run API with proper error handling,\n    timeout support, and flexible output management.\n\n    Example:\n        ```python\n        # Basic command execution\n        result = HostDevice.write_command(\"echo 'Hello World'\")\n        print(result)  # \"Hello World\"\n\n        # With error handling\n        result = HostDevice.write_command(\"nonexistent_command\", quiet=True)\n        print(result)  # None (command failed)\n\n        # With logging\n        result = HostDevice.write_command(\"ls -la\", print_response=True)\n        # Logs command execution details\n        ```\n\n    Note:\n        All methods are static since this class doesn't maintain state.\n        Commands are executed with a 30-second timeout by default.\n    \"\"\"\n\n    @staticmethod\n    def write_command(command: str, print_response: bool = False, quiet: bool = False) -&gt; Optional[str]:\n        \"\"\"Execute a shell command on the local host system.\n\n        Executes the specified command using subprocess.run with proper error\n        handling and timeout support. Returns combined stdout/stderr output\n        or None if the command fails.\n\n        Args:\n            command: Shell command to execute\n            print_response: Whether to log successful command execution details\n            quiet: Whether to suppress error logging for failed commands\n\n        Returns:\n            Combined command output (stdout + stderr) if successful, None if failed\n\n        Raises:\n            None: All exceptions are caught and handled internally\n\n        Example:\n            ```python\n            # Simple command\n            output = HostDevice.write_command(\"date\")\n\n            # Command with error handling\n            output = HostDevice.write_command(\"ping -c 1 nonexistent.host\", quiet=True)\n            if output is None:\n                print(\"Command failed\")\n            ```\n\n        Note:\n            Commands are executed with shell=True, so shell features like pipes\n            and redirects are supported. A 30-second timeout is enforced.\n        \"\"\"\n        try:\n            result = subprocess.run(\n                command,\n                shell=True,\n                capture_output=True,\n                text=True,\n                timeout=30,\n                check=False  # Don't raise exception on non-zero exit\n            )\n\n            if result.returncode != 0:\n                if not quiet:\n                    logger.error(\"Error executing command: %s\", command)\n                    logger.error(\"Error message: %s\", result.stderr)\n                return None\n\n            if print_response and not quiet:\n                logger.debug(\"Command executed successfully: %s\", command)\n                logger.debug(\"Output: %s\", result.stdout)\n\n            # Return combined output (stdout + stderr) if available\n            output_parts = []\n            if result.stdout:\n                output_parts.append(result.stdout)\n            if result.stderr:\n                output_parts.append(result.stderr)\n\n            return \"\\n\".join(output_parts) if output_parts else None\n\n        except subprocess.TimeoutExpired:\n            if not quiet:\n                logger.error(\"Command timed out: %s\", command)\n            return None\n        except OSError:\n            if not quiet:\n                logger.exception(\"Failed to execute command: %s\", command)\n            return None\n</code></pre>"},{"location":"api/device/#router_test_kit.device.HostDevice-functions","title":"Functions","text":""},{"location":"api/device/#router_test_kit.device.HostDevice.write_command","title":"write_command  <code>staticmethod</code>","text":"<pre><code>write_command(\n    command: str,\n    print_response: bool = False,\n    quiet: bool = False,\n) -&gt; Optional[str]\n</code></pre> <p>Execute a shell command on the local host system.</p> <p>Executes the specified command using subprocess.run with proper error handling and timeout support. Returns combined stdout/stderr output or None if the command fails.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Shell command to execute</p> required <code>print_response</code> <code>bool</code> <p>Whether to log successful command execution details</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Whether to suppress error logging for failed commands</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Combined command output (stdout + stderr) if successful, None if failed</p> <p>Raises:</p> Type Description <code>None</code> <p>All exceptions are caught and handled internally</p> Example <pre><code># Simple command\noutput = HostDevice.write_command(\"date\")\n\n# Command with error handling\noutput = HostDevice.write_command(\"ping -c 1 nonexistent.host\", quiet=True)\nif output is None:\n    print(\"Command failed\")\n</code></pre> Note <p>Commands are executed with shell=True, so shell features like pipes and redirects are supported. A 30-second timeout is enforced.</p> Source code in <code>src/router_test_kit/device.py</code> <pre><code>@staticmethod\ndef write_command(command: str, print_response: bool = False, quiet: bool = False) -&gt; Optional[str]:\n    \"\"\"Execute a shell command on the local host system.\n\n    Executes the specified command using subprocess.run with proper error\n    handling and timeout support. Returns combined stdout/stderr output\n    or None if the command fails.\n\n    Args:\n        command: Shell command to execute\n        print_response: Whether to log successful command execution details\n        quiet: Whether to suppress error logging for failed commands\n\n    Returns:\n        Combined command output (stdout + stderr) if successful, None if failed\n\n    Raises:\n        None: All exceptions are caught and handled internally\n\n    Example:\n        ```python\n        # Simple command\n        output = HostDevice.write_command(\"date\")\n\n        # Command with error handling\n        output = HostDevice.write_command(\"ping -c 1 nonexistent.host\", quiet=True)\n        if output is None:\n            print(\"Command failed\")\n        ```\n\n    Note:\n        Commands are executed with shell=True, so shell features like pipes\n        and redirects are supported. A 30-second timeout is enforced.\n    \"\"\"\n    try:\n        result = subprocess.run(\n            command,\n            shell=True,\n            capture_output=True,\n            text=True,\n            timeout=30,\n            check=False  # Don't raise exception on non-zero exit\n        )\n\n        if result.returncode != 0:\n            if not quiet:\n                logger.error(\"Error executing command: %s\", command)\n                logger.error(\"Error message: %s\", result.stderr)\n            return None\n\n        if print_response and not quiet:\n            logger.debug(\"Command executed successfully: %s\", command)\n            logger.debug(\"Output: %s\", result.stdout)\n\n        # Return combined output (stdout + stderr) if available\n        output_parts = []\n        if result.stdout:\n            output_parts.append(result.stdout)\n        if result.stderr:\n            output_parts.append(result.stderr)\n\n        return \"\\n\".join(output_parts) if output_parts else None\n\n    except subprocess.TimeoutExpired:\n        if not quiet:\n            logger.error(\"Command timed out: %s\", command)\n        return None\n    except OSError:\n        if not quiet:\n            logger.exception(\"Failed to execute command: %s\", command)\n        return None\n</code></pre>"},{"location":"api/static_utils/","title":"Static Utils API","text":"<p>The static_utils module provides utility functions for network testing, command execution, and system operations.</p> <p>Static Utilities and Helper Functions Module.</p> <p>This module provides a collection of utility functions for network testing, command execution, and system operations. It includes functions for:</p> <ul> <li>Network operations (ping, packet loss analysis, IP validation)</li> <li>File operations (JSON loading, SCP transfers)</li> <li>System commands (shell command execution)  </li> <li>Test utilities (pytest integration, data processing)</li> </ul> <p>The utilities are designed to support router and network device testing scenarios, providing common operations needed across different test cases.</p> <p>Functions:</p> Name Description <code>Network Utilities</code> <code>- ping</code> <p>Execute ping commands and return results</p> <code>- get_packet_loss</code> <p>Extract packet loss percentage from ping output</p> <code>- is_valid_ip</code> <p>Validate IP address strings (IPv4/IPv6)</p> <code>- get_interface_ips</code> <p>Get IP addresses assigned to network interfaces</p> <code>System Utilities</code> <code>- execute_shell_commands_on_host</code> <p>Execute shell commands with error handling</p> <code>- scp_file_to_home_dir</code> <p>Transfer files using SCP</p> <code>Data Utilities</code> <code>- load_json</code> <p>Load and parse JSON configuration files</p> <code>- print_banner</code> <p>Print formatted banner messages</p> <code>Test Utilities</code> <code>- get_tests</code> <p>Collect pytest test items</p> <code>- TestCollector</code> <p>Pytest plugin for test collection</p> Example <p>Common usage patterns:</p> <pre><code>from router_test_kit.static_utils import ping, get_packet_loss, is_valid_ip\n\n# Network testing\nresult = ping(\"8.8.8.8\", count=3)\nloss = get_packet_loss(result)\nprint(f\"Packet loss: {loss}%\")\n\n# IP validation  \nif is_valid_ip(\"192.168.1.1\"):\n    print(\"Valid IP address\")\n</code></pre> Note <p>Many functions in this module execute system commands or access network resources. Ensure proper permissions and network connectivity when using these utilities in test environments.</p>"},{"location":"api/static_utils/#router_test_kit.static_utils-classes","title":"Classes","text":""},{"location":"api/static_utils/#router_test_kit.static_utils.TestCollector","title":"TestCollector","text":"<p>A pytest plugin to collect test items.</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>class TestCollector:\n    \"\"\"A pytest plugin to collect test items.\"\"\"\n\n    def pytest_collection_finish(self, session: pytest.Session) -&gt; None:\n        \"\"\"Called after test collection has been completed and modified.\"\"\"\n        self.test_items = session.items\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.TestCollector-functions","title":"Functions","text":""},{"location":"api/static_utils/#router_test_kit.static_utils.TestCollector.pytest_collection_finish","title":"pytest_collection_finish","text":"<pre><code>pytest_collection_finish(session: Session) -&gt; None\n</code></pre> <p>Called after test collection has been completed and modified.</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def pytest_collection_finish(self, session: pytest.Session) -&gt; None:\n    \"\"\"Called after test collection has been completed and modified.\"\"\"\n    self.test_items = session.items\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils-functions","title":"Functions","text":""},{"location":"api/static_utils/#router_test_kit.static_utils.get_tests","title":"get_tests","text":"<pre><code>get_tests() -&gt; List[Item]\n</code></pre> <p>Collect test items using pytest collection.</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def get_tests() -&gt; List[pytest.Item]:\n    \"\"\"Collect test items using pytest collection.\"\"\"\n    collector = TestCollector()\n    pytest.main(\n        [\"--no-header\", \"--no-summary\", \"-qq\", \"--collect-only\"], plugins=[collector]\n    )\n    return collector.test_items\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.load_json","title":"load_json","text":"<pre><code>load_json(file_path: str) -&gt; Dict[str, Any]\n</code></pre> <p>Load and parse a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the JSON file</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Parsed JSON data as dictionary</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def load_json(file_path: str) -&gt; Dict[str, Any]:\n    \"\"\"Load and parse a JSON file.\n\n    Args:\n        file_path: Path to the JSON file\n\n    Returns:\n        Parsed JSON data as dictionary\n    \"\"\"\n    with open(file_path, encoding='utf-8') as json_file:\n        data = json.load(json_file)\n    return data\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.print_banner","title":"print_banner","text":"<pre><code>print_banner(\n    *messages: str, banner_legth: int = 80\n) -&gt; None\n</code></pre> <p>Print formatted banner messages with decorative borders.</p> <p>Creates a visually appealing banner by surrounding the provided messages with asterisk borders. Each message is centered within the banner width.</p> <p>Parameters:</p> Name Type Description Default <code>*messages</code> <code>str</code> <p>Variable number of string messages to display in the banner</p> <code>()</code> <code>banner_legth</code> <code>int</code> <p>Width of the banner in characters. Defaults to 80.</p> <code>80</code> Example <pre><code>print_banner(\"Welcome\", \"Router Test Suite\", \"Version 1.0\")\n</code></pre> <p>Output: <pre><code>********************************************************************************\n                                Welcome\n                           Router Test Suite\n                              Version 1.0\n********************************************************************************\n</code></pre></p> Note <p>Messages are logged using the logger.info() method, so they will appear in both console output and log files based on logging configuration.</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def print_banner(*messages: str, banner_legth: int = 80) -&gt; None:\n    \"\"\"Print formatted banner messages with decorative borders.\n\n    Creates a visually appealing banner by surrounding the provided messages\n    with asterisk borders. Each message is centered within the banner width.\n\n    Args:\n        *messages: Variable number of string messages to display in the banner\n        banner_legth: Width of the banner in characters. Defaults to 80.\n\n    Example:\n        ```python\n        print_banner(\"Welcome\", \"Router Test Suite\", \"Version 1.0\")\n        ```\n\n        Output:\n        ```\n        ********************************************************************************\n                                        Welcome\n                                   Router Test Suite\n                                      Version 1.0\n        ********************************************************************************\n        ```\n\n    Note:\n        Messages are logged using the logger.info() method, so they will appear\n        in both console output and log files based on logging configuration.\n    \"\"\"\n    border = \"*\" * banner_legth\n    logger.info(border)\n    for message in messages:\n        logger.info(message.center(banner_legth))\n    logger.info(border)\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.execute_shell_commands_on_host","title":"execute_shell_commands_on_host","text":"<pre><code>execute_shell_commands_on_host(\n    commands: List[str],\n    print_response: bool = False,\n    quiet: bool = False,\n) -&gt; Optional[str]\n</code></pre> <p>Execute shell commands on the host system.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[str]</code> <p>List of commands to execute</p> required <code>print_response</code> <code>bool</code> <p>Whether to log successful command execution</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Whether to suppress error logging</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Combined output of all commands, or None if no output</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def execute_shell_commands_on_host(\n    commands: List[str], print_response: bool = False, quiet: bool = False\n) -&gt; Optional[str]:\n    \"\"\"Execute shell commands on the host system.\n\n    Args:\n        commands: List of commands to execute\n        print_response: Whether to log successful command execution\n        quiet: Whether to suppress error logging\n\n    Returns:\n        Combined output of all commands, or None if no output\n    \"\"\"\n    responses = []\n    for command in commands:\n        try:\n            result = subprocess.run(\n                command,\n                shell=True,\n                capture_output=True,\n                text=True,\n                timeout=30,\n                check=False\n            )\n\n            if result.returncode != 0 and not quiet:\n                logger.error(\"Error executing command: %s\", command)\n                logger.error(\"Error message: %s\", result.stderr)\n            else:\n                if print_response and not quiet:\n                    logger.debug(\"Command executed successfully: %s\", command)\n                    logger.debug(\"Output: %s\", result.stdout)\n\n            if result.stdout:\n                responses.append(result.stdout)\n            if result.stderr:\n                responses.append(result.stderr)\n\n        except subprocess.TimeoutExpired:\n            if not quiet:\n                logger.error(\"Command timed out: %s\", command)\n        except OSError:\n            if not quiet:\n                logger.exception(\"Failed to execute command: %s\", command)\n\n    return \"\\n\".join(responses) if responses else None\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.get_interface_ips","title":"get_interface_ips","text":"<pre><code>get_interface_ips(\n    interface: str,\n) -&gt; Tuple[List[str], List[str]]\n</code></pre> <p>Get IPv4 and IPv6 addresses assigned to a network interface.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>str</code> <p>Name of the network interface</p> required <p>Returns:</p> Type Description <code>Tuple[List[str], List[str]]</code> <p>Tuple of (IPv4 addresses, IPv6 addresses)</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def get_interface_ips(interface: str) -&gt; Tuple[List[str], List[str]]:\n    \"\"\"Get IPv4 and IPv6 addresses assigned to a network interface.\n\n    Args:\n        interface: Name of the network interface\n\n    Returns:\n        Tuple of (IPv4 addresses, IPv6 addresses)\n    \"\"\"\n    response = execute_shell_commands_on_host([f\"ip addr show {interface}\"])\n    if not response:\n        return [], []\n\n    ipv4_pattern = r\"\\binet (\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b)\"\n    ipv4_matches = re.findall(ipv4_pattern, response)\n    ipv6_pattern = r\"\\binet6 ([a-f0-9:]+)\"\n    ipv6_matches = re.findall(ipv6_pattern, response)\n    return ipv4_matches if ipv4_matches else [], ipv6_matches if ipv6_matches else []\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.reboot_device","title":"reboot_device","text":"<pre><code>reboot_device(\n    connection: TelnetConnection, timeout: int = 60\n) -&gt; TelnetConnection\n</code></pre> <p>Reboot a device and wait for it to come back online.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>TelnetConnection</code> <p>Active telnet connection to device</p> required <code>timeout</code> <code>int</code> <p>Maximum time to wait for device to come back online</p> <code>60</code> <p>Returns:</p> Type Description <code>TelnetConnection</code> <p>Renewed connection to the device</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If connection is not established</p> <code>TimeoutError</code> <p>If device doesn't come back online within timeout</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def reboot_device(\n    connection: TelnetConnection, timeout: int = 60\n) -&gt; TelnetConnection:\n    \"\"\"Reboot a device and wait for it to come back online.\n\n    Args:\n        connection: Active telnet connection to device\n        timeout: Maximum time to wait for device to come back online\n\n    Returns:\n        Renewed connection to the device\n\n    Raises:\n        ConnectionError: If connection is not established\n        TimeoutError: If device doesn't come back online within timeout\n    \"\"\"\n    if connection is None or not connection.is_connected:\n        raise ConnectionError(\"Connection is not established. Cannot reboot device.\")\n\n    vm_ip = connection.destination_ip\n    vm = connection.destination_device\n    connection.write_command(\"show expert system command bash\")\n    connection.write_command(\"/sbin/reboot\")\n    connection.disconnect()\n\n    start_time = time.time()\n    while True:\n        packet_loss = get_packet_loss(vm_ip)\n        if packet_loss == 0:\n            break\n        if timeout and time.time() - start_time &gt; timeout:\n            raise TimeoutError(f\"Rebooting device {vm} took too long. Timeout reached.\")\n\n    connection.connect(vm, vm_ip)\n    return connection\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.ping","title":"ping","text":"<pre><code>ping(destination_ip: str, count: int = 1) -&gt; Optional[str]\n</code></pre> <p>Ping a destination and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>destination_ip</code> <code>str</code> <p>IP address to ping</p> required <code>count</code> <code>int</code> <p>Number of ping packets to send</p> <code>1</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Ping command output, or None if command failed</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def ping(destination_ip: str, count: int = 1) -&gt; Optional[str]:\n    \"\"\"Ping a destination and return the result.\n\n    Args:\n        destination_ip: IP address to ping\n        count: Number of ping packets to send\n\n    Returns:\n        Ping command output, or None if command failed\n    \"\"\"\n    return execute_shell_commands_on_host([f\"ping -c {count} {destination_ip}\"])\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.get_packet_loss","title":"get_packet_loss","text":"<pre><code>get_packet_loss(response: str) -&gt; Optional[str]\n</code></pre> <p>Extract packet loss percentage from ping command output.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>Output from ping command</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Packet loss percentage as string, or None if not found</p> Example <p>'2 packets transmitted, 2 received, 0% packet loss, time 11ms' Returns '0'</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def get_packet_loss(response: str) -&gt; Optional[str]:\n    \"\"\"Extract packet loss percentage from ping command output.\n\n    Args:\n        response: Output from ping command\n\n    Returns:\n        Packet loss percentage as string, or None if not found\n\n    Example:\n        '2 packets transmitted, 2 received, 0% packet loss, time 11ms'\n        Returns '0'\n    \"\"\"\n    if not response:\n        logger.critical(\"Ping: Empty response provided\")\n        return None\n\n    match = re.search(r\"\\d+(?=%)\", response)\n    if match:\n        return match.group()\n    else:\n        logger.critical(\n            \"Ping: Could not find packet loss percentage in response: %s\", response\n        )\n        return None\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.is_valid_ip","title":"is_valid_ip","text":"<pre><code>is_valid_ip(ip: str) -&gt; bool\n</code></pre> <p>Check if a string represents a valid IP address (IPv4 or IPv6).</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>String to validate as IP address</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid IP address, False otherwise</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def is_valid_ip(ip: str) -&gt; bool:\n    \"\"\"Check if a string represents a valid IP address (IPv4 or IPv6).\n\n    Args:\n        ip: String to validate as IP address\n\n    Returns:\n        True if valid IP address, False otherwise\n    \"\"\"\n    try:\n        ipaddress.ip_address(ip)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/static_utils/#router_test_kit.static_utils.scp_file_to_home_dir","title":"scp_file_to_home_dir","text":"<pre><code>scp_file_to_home_dir(\n    local_file_path: str, user_at_ip: str, password: str\n) -&gt; None\n</code></pre> <p>Copy a local file to remote host's home directory using SCP.</p> <p>Parameters:</p> Name Type Description Default <code>local_file_path</code> <code>str</code> <p>Path to local file to copy</p> required <code>user_at_ip</code> <code>str</code> <p>Remote destination in format 'user@ip'</p> required <code>password</code> <code>str</code> <p>Password for remote authentication</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If local file or remote path is invalid</p> <code>ValueError</code> <p>If unknown error occurs during transfer</p> Source code in <code>src/router_test_kit/static_utils.py</code> <pre><code>def scp_file_to_home_dir(local_file_path: str, user_at_ip: str, password: str) -&gt; None:\n    \"\"\"Copy a local file to remote host's home directory using SCP.\n\n    Args:\n        local_file_path: Path to local file to copy\n        user_at_ip: Remote destination in format 'user@ip'\n        password: Password for remote authentication\n\n    Raises:\n        FileNotFoundError: If local file or remote path is invalid\n        ValueError: If unknown error occurs during transfer\n    \"\"\"\n    # Check if sshpass is installed on device\n    host_vm = HostDevice()\n    response = host_vm.write_command(\"sshpass\")\n\n    if not response or \"Usage: sshpass\" not in response:\n        logger.critical(\n            'sshpass is not installed on the device. Please install it by \"sudo apt install sshpass\"'\n        )\n        return\n\n    command = f\"sshpass -p {password} scp {local_file_path} {user_at_ip}:~\"\n    response = host_vm.write_command(command)\n\n    if response is None:\n        return\n    elif \"No such file or directory\" in response:\n        logger.critical(\n            \"Some file path is not valid. Local: %s, @: %s\", local_file_path, user_at_ip\n        )\n        raise FileNotFoundError\n    else:\n        logger.critical(\n            \"Unknown error occurred while copying file to the device. Got response: %s\", response\n        )\n        raise ValueError(\"SCP transfer failed\")\n</code></pre>"}]}